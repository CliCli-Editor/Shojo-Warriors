// Generated by dts-bundle-generator v9.5.1

import * as https from 'https';
import is from 'is';
import * as jsonc from 'jsonc-parser';
import * as vm from 'vm';
import * as vscode from 'vscode';

declare interface Buffer$1 extends ArrayBuffer {
}
declare enum RelationshipType {
	None = 0,
	OfficeDocument = 1,
	Worksheet = 2,
	CalcChain = 3,
	SharedStrings = 4,
	Styles = 5,
	Theme = 6,
	Hyperlink = 7
}
declare enum DocumentType {
	Xlsx = 1
}
declare const enum PaperSize {
	Legal = 5,
	Executive = 7,
	A4 = 9,
	A5 = 11,
	B5 = 13,
	Envelope_10 = 20,
	Envelope_DL = 27,
	Envelope_C5 = 28,
	Envelope_B5 = 34,
	Envelope_Monarch = 37,
	Double_Japan_Postcard_Rotated = 82,
	K16_197x273_mm = 119
}
interface WorksheetViewCommon {
	/**
	 * Sets the worksheet view's orientation to right-to-left, `false` by default
	 */
	rightToLeft: boolean;
	/**
	 * The currently selected cell
	 */
	activeCell: string;
	/**
	 * Shows or hides the ruler in Page Layout, `true` by default
	 */
	showRuler: boolean;
	/**
	 * Shows or hides the row and column headers (e.g. A1, B1 at the top and 1,2,3 on the left,
	 * `true` by default
	 */
	showRowColHeaders: boolean;
	/**
	 * Shows or hides the gridlines (shown for cells where borders have not been defined),
	 * `true` by default
	 */
	showGridLines: boolean;
	/**
	 * 	Percentage zoom to use for the view, `100` by default
	 */
	zoomScale: number;
	/**
	 * 	Normal zoom for the view, `100` by default
	 */
	zoomScaleNormal: number;
}
interface WorksheetViewNormal {
	/**
	 * Controls the view state
	 */
	state: "normal";
	/**
	 * Presentation style
	 */
	style: "pageBreakPreview" | "pageLayout";
}
interface WorksheetViewFrozen {
	/**
	 * Where a number of rows and columns to the top and left are frozen in place.
	 * Only the bottom left section will scroll
	 */
	state: "frozen";
	/**
	 * Presentation style
	 */
	style?: "pageBreakPreview";
	/**
	 * How many columns to freeze. To freeze rows only, set this to 0 or undefined
	 */
	xSplit?: number;
	/**
	 * How many rows to freeze. To freeze columns only, set this to 0 or undefined
	 */
	ySplit?: number;
	/**
	 * Which cell will be top-left in the bottom-right pane. Note: cannot be a frozen cell.
	 * Defaults to first unfrozen cell
	 */
	topLeftCell?: string;
}
interface WorksheetViewSplit {
	/**
	 * Where the view is split into 4 sections, each semi-independently scrollable.
	 */
	state: "split";
	/**
	 * Presentation style
	 */
	style?: "pageBreakPreview" | "pageLayout";
	/**
	 * How many points from the left to place the splitter.
	 * To split vertically, set this to 0 or undefined
	 */
	xSplit?: number;
	/**
	 * How many points from the top to place the splitter.
	 * To split horizontally, set this to 0 or undefined
	 */
	ySplit?: number;
	/**
	 * Which cell will be top-left in the bottom-right pane
	 */
	topLeftCell?: string;
	/**
	 * Which pane will be active
	 */
	activePane?: "topLeft" | "topRight" | "bottomLeft" | "bottomRight";
}
type WorksheetView = WorksheetViewCommon & (WorksheetViewNormal | WorksheetViewFrozen | WorksheetViewSplit);
interface WorkbookView {
	x: number;
	y: number;
	width: number;
	height: number;
	firstSheet: number;
	activeTab: number;
	visibility: string;
}
type FillPatterns = "none" | "solid" | "darkVertical" | "darkHorizontal" | "darkGrid" | "darkTrellis" | "darkDown" | "darkUp" | "lightVertical" | "lightHorizontal" | "lightGrid" | "lightTrellis" | "lightDown" | "lightUp" | "darkGray" | "mediumGray" | "lightGray" | "gray125" | "gray0625";
interface FillPattern {
	type: "pattern";
	pattern: FillPatterns;
	fgColor?: Partial<Color>;
	bgColor?: Partial<Color>;
}
interface GradientStop {
	position: number;
	color: Partial<Color>;
}
interface FillGradientAngle {
	type: "gradient";
	gradient: "angle";
	/**
	 * For 'angle' gradient, specifies the direction of the gradient. 0 is from the left to the right.
	 * Values from 1 - 359 rotates the direction clockwise
	 */
	degree: number;
	/**
	 * Specifies the gradient colour sequence. Is an array of objects containing position and
	 * color starting with position 0 and ending with position 1.
	 * Intermediary positions may be used to specify other colours on the path.
	 */
	stops: GradientStop[];
}
interface FillGradientPath {
	type: "gradient";
	gradient: "path";
	/**
	 * For 'path' gradient. Specifies the relative coordinates for the start of the path.
	 * 'left' and 'top' values range from 0 to 1
	 */
	center: {
		left: number;
		top: number;
	};
	/**
	 * Specifies the gradient colour sequence. Is an array of objects containing position and
	 * color starting with position 0 and ending with position 1.
	 * Intermediary positions may be used to specify other colours on the path.
	 */
	stops: GradientStop[];
}
type Fill = FillPattern | FillGradientAngle | FillGradientPath;
interface Font {
	name: string;
	size: number;
	family: number;
	scheme: "minor" | "major" | "none";
	charset: number;
	color: Partial<Color>;
	bold: boolean;
	italic: boolean;
	underline: boolean | "none" | "single" | "double" | "singleAccounting" | "doubleAccounting";
	vertAlign: "superscript" | "subscript";
	strike: boolean;
	outline: boolean;
}
type BorderStyle = "thin" | "dotted" | "hair" | "medium" | "double" | "thick" | "dashed" | "dashDot" | "dashDotDot" | "slantDashDot" | "mediumDashed" | "mediumDashDotDot" | "mediumDashDot";
interface Color {
	/**
	 * Hex string for alpha-red-green-blue e.g. FF00FF00
	 */
	argb: string;
	/**
	 * Choose a theme by index
	 */
	theme: number;
}
interface Border {
	style: BorderStyle;
	color: Partial<Color>;
}
interface BorderDiagonal extends Border {
	up: boolean;
	down: boolean;
}
interface Borders {
	top: Partial<Border>;
	left: Partial<Border>;
	bottom: Partial<Border>;
	right: Partial<Border>;
	diagonal: Partial<BorderDiagonal>;
}
interface Margins {
	top: number;
	left: number;
	bottom: number;
	right: number;
	header: number;
	footer: number;
}
declare enum ReadingOrder {
	LeftToRight = 1,
	RightToLeft = 2
}
interface Alignment {
	horizontal: "left" | "center" | "right" | "fill" | "justify" | "centerContinuous" | "distributed";
	vertical: "top" | "middle" | "bottom" | "distributed" | "justify";
	wrapText: boolean;
	shrinkToFit: boolean;
	indent: number;
	readingOrder: "rtl" | "ltr";
	textRotation: number | "vertical";
}
interface Protection {
	locked: boolean;
	hidden: boolean;
}
interface Style {
	numFmt: string;
	font: Partial<Font>;
	alignment: Partial<Alignment>;
	protection: Partial<Protection>;
	border: Partial<Borders>;
	fill: Fill;
}
type DataValidationOperator = "between" | "notBetween" | "equal" | "notEqual" | "greaterThan" | "lessThan" | "greaterThanOrEqual" | "lessThanOrEqual";
interface DataValidation {
	type: "list" | "whole" | "decimal" | "date" | "textLength" | "custom";
	formulae: any[];
	allowBlank?: boolean;
	operator?: DataValidationOperator;
	error?: string;
	errorTitle?: string;
	errorStyle?: string;
	prompt?: string;
	promptTitle?: string;
	showErrorMessage?: boolean;
	showInputMessage?: boolean;
}
declare enum ErrorValue {
	NotApplicable = "#N/A",
	Ref = "#REF!",
	Name = "#NAME?",
	DivZero = "#DIV/0!",
	Null = "#NULL!",
	Value = "#VALUE!",
	Num = "#NUM!"
}
interface CellErrorValue {
	error: "#N/A" | "#REF!" | "#NAME?" | "#DIV/0!" | "#NULL!" | "#VALUE!" | "#NUM!";
}
interface RichText {
	text: string;
	font?: Partial<Font>;
}
interface CellRichTextValue {
	richText: RichText[];
}
interface CellHyperlinkValue {
	text: string;
	hyperlink: string;
	tooltip?: string;
}
interface CellFormulaValue {
	formula: string;
	result?: number | string | boolean | Date | CellErrorValue;
	date1904?: boolean;
}
interface CellSharedFormulaValue {
	sharedFormula: string;
	readonly formula?: string;
	result?: number | string | boolean | Date | CellErrorValue;
	date1904?: boolean;
}
declare enum ValueType {
	Null = 0,
	Merge = 1,
	Number = 2,
	String = 3,
	Date = 4,
	Hyperlink = 5,
	Formula = 6,
	SharedString = 7,
	RichText = 8,
	Boolean = 9,
	Error = 10
}
declare enum FormulaType {
	None = 0,
	Master = 1,
	Shared = 2
}
type CellValue = null | number | string | boolean | Date | undefined | CellErrorValue | CellRichTextValue | CellHyperlinkValue | CellFormulaValue | CellSharedFormulaValue;
interface CommentMargins {
	insetmode: "auto" | "custom";
	inset: Number[];
}
interface CommentProtection {
	locked: "True" | "False";
	lockText: "True" | "False";
}
type CommentEditAs = "twoCells" | "oneCells" | "absolute";
interface Comment {
	texts?: RichText[];
	margins?: Partial<CommentMargins>;
	protection?: Partial<CommentProtection>;
	editAs?: CommentEditAs;
}
interface CellModel {
	address: Address;
	style: Style;
	type: ValueType;
	text?: string;
	hyperlink?: string;
	value?: CellValue;
	master: string;
	formula?: string;
	sharedFormula?: string;
	result?: string | number | any;
	comment: Comment;
}
interface Cell extends Style, Address {
	readonly worksheet: Worksheet;
	readonly workbook: Workbook;
	readonly effectiveType: ValueType;
	readonly isMerged: boolean;
	readonly master: Cell;
	readonly isHyperlink: boolean;
	readonly hyperlink: string; // todo
	readonly text: string;
	readonly fullAddress: {
		sheetName: string;
		address: string;
		row: number;
		col: number;
	};
	model: CellModel;
	/**
	 * Assign (or get) a name for a cell (will overwrite any other names that cell had)
	 */
	name: string;
	/**
	 * Assign (or get) an array of names for a cell (cells can have more than one name)
	 */
	names: string[];
	/**
	 * Cells can define what values are valid or not and provide
	 * prompting to the user to help guide them.
	 */
	dataValidation: DataValidation;
	/**
	 * Value of the cell
	 */
	value: CellValue;
	/**
	 * comment of the cell
	 */
	note: string | Comment;
	/**
	 * convenience getter to access the formula
	 */
	readonly formula: string;
	/**
	 * convenience getter to access the formula result
	 */
	readonly result: number | string | Date;
	/**
	 * The type of the cell's value
	 */
	readonly type: ValueType;
	/**
	 * The type of the cell's formula
	 */
	readonly formulaType: FormulaType;
	/**
	 * The styles of the cell
	 */
	style: Partial<Style>;
	addName(name: string): void;
	/**
	 * Remove a name from a cell
	 */
	removeName(name: string): void;
	removeAllNames(): void;
	destroy(): void;
	toCsvString(): string;
	release(): void;
	addMergeRef(): void;
	releaseMergeRef(): void;
	merge(master: Cell, ignoreStyle?: boolean): void;
	unmerge(): void;
	isMergedTo(master: Cell): boolean;
	toString(): string;
}
interface RowModel {
	cells: CellModel[];
	number: number;
	min: number;
	max: number;
	height: number;
	style: Partial<Style>;
	hidden: boolean;
	outlineLevel: number;
	collapsed: boolean;
}
interface Row extends Style {
	readonly worksheet: Worksheet;
	readonly hasValues: boolean;
	readonly dimensions: number;
	model: Partial<RowModel> | null;
	/**
	 * Set a specific row height
	 */
	height: number;
	/**
	 * Make row hidden
	 */
	hidden: boolean;
	/**
	 * Get a row as a sparse array
	 */
	// readonly values: CellValue[];
	values: CellValue[] | {
		[key: string]: CellValue;
	};
	/**
	 * Set an outline level for rows
	 */
	outlineLevel?: number;
	/**
	 * The row number
	 */
	readonly number: number;
	/**
	 * Indicate the collapsed state based on outlineLevel
	 */
	readonly collapsed: boolean;
	/**
	 * Number of cells including empty ones
	 */
	readonly cellCount: number;
	/**
	 * Number of non-empty cells
	 */
	readonly actualCellCount: number;
	/**
	 * Get cell by number, column letter or column key
	 */
	getCell(indexOrKey: number | string): Cell;
	findCell(colNumber: number): Cell | undefined;
	getCellEx(address: Address): Cell;
	/**
	 * Iterate over all non-null cells in a row
	 */
	eachCell(callback: (cell: Cell, colNumber: number) => void): void;
	/**
	 * Iterate over all cells in a row (including empty cells)
	 */
	eachCell(opt: {
		includeEmpty: boolean;
	}, callback: (cell: Cell, colNumber: number) => void): void;
	/**
	 * Cut one or more cells (cells to the right are shifted left)
	 *
	 * Note: this operation will not affect other rows
	 */
	splice(start: number, count: number, ...insert: any[]): void;
	/**
	 * Commit a completed row to stream
	 */
	commit(): void;
	destroy(): void;
	addPageBreak(lft?: number, rght?: number): void;
}
interface Column {
	/**
	 * Can be a string to set one row high header or an array to set multi-row high header
	 */
	header?: string | string[];
	/**
	 * The name of the properties associated with this column in each row
	 */
	key?: string;
	/**
	 * The width of the column
	 */
	width?: number;
	/**
	 * Set an outline level for columns
	 */
	outlineLevel: number;
	/**
	 * Hides the column
	 */
	hidden: boolean;
	/**
	 * Styles applied to the column
	 */
	style: Partial<Style>;
	/**
	 * The cell values in the column
	 */
	values: ReadonlyArray<CellValue>;
	/**
	 * Column letter key
	 */
	readonly letter: string;
	readonly number: number;
	readonly worksheet: Worksheet;
	readonly isCustomWidth: boolean;
	readonly headers: string[];
	readonly isDefault: boolean;
	readonly headerCount: number;
	/**
	 * Below properties read from style
	 */
	border?: Partial<Borders>;
	fill?: Fill;
	numFmt?: string;
	font?: Partial<Font>;
	alignment?: Partial<Alignment>;
	protection?: Partial<Protection>;
	toString(): string;
	equivalentTo(other: Column): boolean;
	/**
	 * indicate the collapsed state based on outlineLevel
	 */
	readonly collapsed: boolean;
	/**
	 * Iterate over all current cells in this column
	 */
	eachCell(callback: (cell: Cell, rowNumber: number) => void): void;
	/**
	 * Iterate over all current cells in this column including empty cells
	 */
	eachCell(opt: {
		includeEmpty: boolean;
	}, callback: (cell: Cell, rowNumber: number) => void): void;
	defn: any; //todo
}
interface PageSetup {
	/**
	 * Whitespace on the borders of the page. Units are inches.
	 */
	margins: Margins;
	/**
	 * Orientation of the page - i.e. taller (`'portrait'`) or wider (`'landscape'`).
	 *
	 * `'portrait'` by default
	 */
	orientation: "portrait" | "landscape";
	/**
	 * Horizontal Dots per Inch. Default value is 4294967295
	 */
	horizontalDpi: number;
	/**
	 * Vertical Dots per Inch. Default value is 4294967295
	 */
	verticalDpi: number;
	/**
	 * Whether to use fitToWidth and fitToHeight or scale settings.
	 *
	 * Default is based on presence of these settings in the pageSetup object - if both are present,
	 * scale wins (i.e. default will be false)
	 */
	fitToPage: boolean;
	/**
	 * How many pages wide the sheet should print on to. Active when fitToPage is true
	 *
	 * Default is 1
	 */
	fitToWidth: number;
	/**
	 * How many pages high the sheet should print on to. Active when fitToPage is true
	 *
	 * Default is 1
	 */
	fitToHeight: number;
	/**
	 * Percentage value to increase or reduce the size of the print. Active when fitToPage is false
	 *
	 * Default is 100
	 */
	scale: number;
	/**
	 * Which order to print the pages.
	 *
	 * Default is `downThenOver`
	 */
	pageOrder: "downThenOver" | "overThenDown";
	/**
	 * Print without colour
	 *
	 * false by default
	 */
	blackAndWhite: boolean;
	/**
	 * Print with less quality (and ink)
	 *
	 * false by default
	 */
	draft: boolean;
	/**
	 * Where to place comments
	 *
	 * Default is `None`
	 */
	cellComments: "atEnd" | "asDisplayed" | "None";
	/**
	 * Where to show errors
	 *
	 * Default is `displayed`
	 */
	errors: "dash" | "blank" | "NA" | "displayed";
	/**
	 * 	What paper size to use (see below)
	 *
	 * | Name                          | Value       |
	 * | ----------------------------- | ---------   |
	 * | Letter                        | `undefined` |
	 * | Legal                         |  `5`        |
	 * | Executive                     |  `7`        |
	 * | A4                            |  `9`        |
	 * | A5                            |  `11`       |
	 * | B5 (JIS)                      |  `13`       |
	 * | Envelope #10                  |  `20`       |
	 * | Envelope DL                   |  `27`       |
	 * | Envelope C5                   |  `28`       |
	 * | Envelope B5                   |  `34`       |
	 * | Envelope Monarch              |  `37`       |
	 * | Double Japan Postcard Rotated |  `82`       |
	 * | 16K 197x273 mm                |  `119`      |
	 */
	paperSize: PaperSize;
	/**
	 * Whether to show the row numbers and column letters, `false` by default
	 */
	showRowColHeaders: boolean;
	/**
	 * Whether to show grid lines, `false` by default
	 */
	showGridLines: boolean;
	/**
	 * Which number to use for the first page
	 */
	firstPageNumber: number;
	/**
	 * 	Whether to center the sheet data horizontally, `false` by default
	 */
	horizontalCentered: boolean;
	/**
	 * 	Whether to center the sheet data vertically, `false` by default
	 */
	verticalCentered: boolean;
	/**
	 * Set Print Area for a sheet, e.g. `'A1:G20'`
	 */
	printArea: string;
	/**
	 * Repeat specific rows on every printed page, e.g. `'1:3'`
	 */
	printTitlesRow: string;
	/**
	 * Repeat specific columns on every printed page, e.g. `'A:C'`
	 */
	printTitlesColumn: string;
}
interface HeaderFooter {
	/**
	 * Set the value of differentFirst as true, which indicates that headers/footers for first page are different from the other pages, `false` by default
	 */
	differentFirst: boolean;
	/**
	 * Set the value of differentOddEven as true, which indicates that headers/footers for odd and even pages are different, `false` by default
	 */
	differentOddEven: boolean;
	/**
	 * Set header string for odd pages, could format the string and `null` by default
	 */
	oddHeader: string;
	/**
	 * Set footer string for odd pages, could format the string and `null` by default
	 */
	oddFooter: string;
	/**
	 * Set header string for even pages, could format the string and `null` by default
	 */
	evenHeader: string;
	/**
	 * Set footer string for even pages, could format the string and `null` by default
	 */
	evenFooter: string;
	/**
	 * Set header string for the first page, could format the string and `null` by default
	 */
	firstHeader: string;
	/**
	 * Set footer string for the first page, could format the string and `null` by default
	 */
	firstFooter: string;
}
type AutoFilter = string | {
	from: string | {
		row: number;
		column: number;
	};
	to: string | {
		row: number;
		column: number;
	};
};
interface WorksheetProtection {
	objects: boolean;
	scenarios: boolean;
	selectLockedCells: boolean;
	selectUnlockedCells: boolean;
	formatCells: boolean;
	formatColumns: boolean;
	formatRows: boolean;
	insertColumns: boolean;
	insertRows: boolean;
	insertHyperlinks: boolean;
	deleteColumns: boolean;
	deleteRows: boolean;
	sort: boolean;
	autoFilter: boolean;
	pivotTables: boolean;
	spinCount: number;
}
interface Image {
	extension: "jpeg" | "png" | "gif";
	base64?: string;
	filename?: string;
	buffer?: Buffer$1;
}
interface IAnchor {
	col: number;
	row: number;
	nativeCol: number;
	nativeRow: number;
	nativeColOff: number;
	nativeRowOff: number;
}
declare class Anchor implements IAnchor {
	col: number;
	nativeCol: number;
	nativeColOff: number;
	nativeRow: number;
	nativeRowOff: number;
	row: number;
	private readonly colWidth: number;
	private readonly rowHeight: number;
	worksheet: Worksheet;
	constructor(model?: IAnchor | object);
}
interface ImageRange {
	tl: Anchor;
	br: Anchor;
}
interface ImagePosition {
	tl: {
		col: number;
		row: number;
	};
	ext: {
		width: number;
		height: number;
	};
}
interface ImageHyperlinkValue {
	hyperlink: string;
	tooltip?: string;
}
interface Range extends Location {
	sheetName: string;
	tl: string;
	$t$l: string;
	br: string;
	$b$r: string;
	range: string;
	$range: string;
	shortRange: string;
	$shortRange: string;
	count: number;
	decode(): void;
	decode(v: Range): void;
	decode(v: string): void;
	decode(v: Location): void;
	decode(top: number, left: number, bottom: number, right: number, sheetName?: string): void;
	decode(tl: string, br: string, sheetName?: string): void;
	decode(v: [
		string,
		string
	]): void;
	decode(v: [
		string,
		string,
		string
	]): void;
	decode(v: [
		number,
		number,
		number,
		number
	]): void;
	decode(v: [
		number,
		number,
		number,
		number,
		string
	]): void;
	expand(top: number, left: number, bottom: number, right: number): void;
	expandRow(row: Row): void;
	expandToAddress(addressStr: string): void;
	toString(): string;
	intersects(other: Range): boolean;
	contains(addressStr: string): boolean;
	containsEx(address: Partial<{
		sheetName: string;
		row: number;
		col: number;
	}>): boolean;
}
interface RowBreak {
	id: number;
	max: number;
	min: number;
	man: number;
}
interface WorksheetModel {
	id: number;
	name: string;
	// dataValidations: this.dataValidations.model,
	properties: WorksheetProperties;
	pageSetup: Partial<PageSetup>;
	headerFooter: Partial<HeaderFooter>;
	rowBreaks: RowBreak[];
	views: WorksheetView[];
	autoFilter: AutoFilter;
	media: Media[];
	merges: Range["range"][];
}
type WorksheetState = "visible" | "hidden" | "veryHidden";
type CellIsOperators = "equal" | "greaterThan" | "lessThan" | "between";
type ContainsTextOperators = "containsText" | "containsBlanks" | "notContainsBlanks" | "containsErrors" | "notContainsErrors";
type TimePeriodTypes = "lastWeek" | "thisWeek" | "nextWeek" | "yesterday" | "today" | "tomorrow" | "last7Days" | "lastMonth" | "thisMonth" | "nextMonth";
type IconSetTypes = "5Arrows" | "5ArrowsGray" | "5Boxes" | "5Quarters" | "5Rating" | "4Arrows" | "4ArrowsGray" | "4Rating" | "4RedToBlack" | "4TrafficLights" | "NoIcons" | "3Arrows" | "3ArrowsGray" | "3Flags" | "3Signs" | "3Stars" | "3Symbols" | "3Symbols2" | "3TrafficLights1" | "3TrafficLights2" | "3Triangles";
type CfvoTypes = "percentile" | "percent" | "num" | "min" | "max" | "formula" | "autoMin" | "autoMax";
interface Cvfo {
	type: CfvoTypes;
	value?: number;
}
interface ConditionalFormattingBaseRule {
	priority: number;
	style?: Partial<Style>;
}
interface ExpressionRuleType extends ConditionalFormattingBaseRule {
	type: "expression";
	formulae?: any[];
}
interface CellIsRuleType extends ConditionalFormattingBaseRule {
	type: "cellIs";
	formulae?: any[];
	operator?: CellIsOperators;
}
interface Top10RuleType extends ConditionalFormattingBaseRule {
	type: "top10";
	rank: number;
	percent: boolean;
	bottom: boolean;
}
interface AboveAverageRuleType extends ConditionalFormattingBaseRule {
	type: "aboveAverage";
	aboveAverage: boolean;
}
interface ColorScaleRuleType extends ConditionalFormattingBaseRule {
	type: "colorScale";
	cfvo?: Cvfo[];
	color?: Partial<Color>[];
}
interface IconSetRuleType extends ConditionalFormattingBaseRule {
	type: "iconSet";
	showValue?: boolean;
	reverse?: boolean;
	custom?: boolean;
	iconSet?: IconSetTypes;
	cfvo?: Cvfo[];
}
interface ContainsTextRuleType extends ConditionalFormattingBaseRule {
	type: "containsText";
	operator?: ContainsTextOperators;
	text?: string;
}
interface TimePeriodRuleType extends ConditionalFormattingBaseRule {
	type: "timePeriod";
	timePeriod?: TimePeriodTypes;
}
interface DataBarRuleType extends ConditionalFormattingBaseRule {
	type: "dataBar";
	gradient?: boolean;
	minLength?: number;
	maxLength?: number;
	showValue?: boolean;
	border?: boolean;
	negativeBarColorSameAsPositive?: boolean;
	negativeBarBorderColorSameAsPositive?: boolean;
	axisPosition?: "auto" | "middle" | "none";
	direction?: "context" | "leftToRight" | "rightToLeft";
	cfvo?: Cvfo[];
}
type ConditionalFormattingRule = ExpressionRuleType | CellIsRuleType | Top10RuleType | AboveAverageRuleType | ColorScaleRuleType | IconSetRuleType | ContainsTextRuleType | TimePeriodRuleType | DataBarRuleType;
type RowValues = CellValue[] | {
	[key: string]: CellValue;
} | undefined | null;
interface ConditionalFormattingOptions {
	ref: string;
	rules: ConditionalFormattingRule[];
}
interface Worksheet {
	readonly id: number;
	name: string;
	readonly workbook: Workbook;
	readonly hasMerges: boolean;
	readonly dimensions: Range;
	/**
	 * Contains information related to how a worksheet is printed
	 */
	pageSetup: Partial<PageSetup>;
	/**
	 * Worksheet Header and Footer
	 */
	headerFooter: Partial<HeaderFooter>;
	/**
	 * Worksheet State
	 */
	state: WorksheetState;
	/**
	 * Worksheet Properties
	 */
	properties: WorksheetProperties;
	/**
	 * Open panes representing the sheet
	 */
	views: Array<Partial<WorksheetView>>;
	/**
	 * Apply an auto filter to your worksheet.
	 */
	autoFilter?: AutoFilter;
	destroy(): void;
	/**
	 * A count of the number of rows that have values. If a mid-document row is empty, it will not be included in the count.
	 */
	readonly actualRowCount: number;
	/**
	 * The total column size of the document. Equal to the maximum cell count from all of the rows
	 */
	readonly columnCount: number;
	/**
	 * Get the last column in a worksheet
	 */
	readonly lastColumn: Column | undefined;
	/**
	 * A count of the number of columns that have values.
	 */
	readonly actualColumnCount: number;
	getColumnKey(key: string): Column;
	setColumnKey(key: string, value: Column): void;
	deleteColumnKey(key: string): void;
	eachColumnKey(callback: (col: Column, index: number) => void): void;
	/**
	 * Access an individual columns by key, letter and 1-based column number
	 */
	getColumn(indexOrKey: number | string): Column;
	/**
	 * Cut one or more columns (columns to the right are shifted left)
	 * and optionally insert more
	 *
	 * If column properties have been definde, they will be cut or moved accordingly
	 *
	 * Known Issue: If a splice causes any merged cells to move, the results may be unpredictable
	 *
	 * Also: If the worksheet has more rows than values in the colulmn inserts,
	 * the rows will still be shifted as if the values existed
	 */
	spliceColumns(start: number, count: number, ...insert: any[][]): void;
	/**
	 * Add column headers and define column keys and widths.
	 *
	 * Note: these column structures are a workbook-building convenience only,
	 * apart from the column width, they will not be fully persisted.
	 */
	columns: Array<Partial<Column>>;
	/**
	 * The total row size of the document. Equal to the row number of the last row that has values.
	 */
	readonly rowCount: number;
	/**
	 * Get the last editable row in a worksheet (or undefined if there are none)
	 */
	readonly lastRow: Row | undefined;
	/**
	 * Tries to find and return row for row no, else undefined
	 *
	 * @param row The 1-index row number
	 */
	findRow(row: number): Row | undefined;
	/**
	 * Tries to find and return rows for row no start and length, else undefined
	 *
	 * @param start The 1-index starting row number
	 * @param length The length of the expected array
	 */
	findRows(start: number, length: number): Row[] | undefined;
	/**
	 * Cut one or more rows (rows below are shifted up)
	 * and optionally insert more
	 *
	 * Known Issue: If a splice causes any merged cells to move, the results may be unpredictable
	 */
	spliceRows(start: number, count: number, ...insert: any[][]): void;
	/**
	 * Add a couple of Rows by key-value, after the last current row, using the column keys,
	 * or add a row by contiguous Array (assign to columns A, B & C)
	 */
	addRow(data: any[] | any, style?: string): Row;
	/**
	 * Add multiple rows by providing an array of arrays or key-value pairs
	 */
	addRows(rows: any[], style?: string): Row[];
	/**
	 * Insert a Row by key-value, at the position (shifiting down all rows from position),
	 * using the column keys, or add a row by contiguous Array (assign to columns A, B & C)
	 */
	insertRow(pos: number, value: any[] | any, style?: string): Row;
	/**
	 * Insert multiple rows at position (shifiting down all rows from position)
	 * by providing an array of arrays or key-value pairs
	 */
	insertRows(pos: number, values: any[], style?: string): Row[];
	/**
	 * Duplicate rows and insert new rows
	 */
	duplicateRow(rowNum: number, count: number, insert: boolean): void;
	/**
	 * Get or create row by 1-based index
	 */
	getRow(index: number): Row;
	/**
	 * Get or create rows by 1-based index
	 */
	getRows(start: number, length: number): Row[] | undefined;
	/**
	 * Iterate over all rows that have values in a worksheet
	 */
	eachRow(callback: (row: Row, rowNumber: number) => void): void;
	/**
	 * Iterate over all rows (including empty rows) in a worksheet
	 */
	eachRow(opt: {
		includeEmpty: boolean;
	}, callback: (row: Row, rowNumber: number) => void): void;
	/**
	 * return all rows as sparse array
	 */
	getSheetValues(): RowValues[];
	/**
	 * returns the cell at [r,c] or address given by r. If not found, return undefined
	 */
	findCell(r: number | string, c: number | string): Cell | undefined;
	/**
	 * Get or create cell
	 */
	getCell(r: number | string, c?: number | string): Cell;
	/**
	 * Merge cells, either:
	 *
	 * tlbr string, e.g. `'A4:B5'`
	 *
	 * tl string, br string, e.g. `'G10', 'H11'`
	 *
	 * t, l, b, r numbers, e.g. `10,11,12,13`
	 */
	mergeCells(): void;
	mergeCells(v: Range): void;
	mergeCells(v: string): void;
	mergeCells(v: Location): void;
	mergeCells(top: number, left: number, bottom: number, right: number, sheetName?: string): void;
	mergeCells(tl: string, br: string, sheetName?: string): void;
	mergeCells(v: [
		string,
		string
	]): void;
	mergeCells(v: [
		string,
		string,
		string
	]): void;
	mergeCells(v: [
		number,
		number,
		number,
		number
	]): void;
	mergeCells(v: [
		number,
		number,
		number,
		number,
		string
	]): void;
	mergeCellsWithoutStyle(): void;
	mergeCellsWithoutStyle(v: Range): void;
	mergeCellsWithoutStyle(v: string): void;
	mergeCellsWithoutStyle(v: Location): void;
	mergeCellsWithoutStyle(top: number, left: number, bottom: number, right: number, sheetName?: string): void;
	mergeCellsWithoutStyle(tl: string, br: string, sheetName?: string): void;
	mergeCellsWithoutStyle(v: [
		string,
		string
	]): void;
	mergeCellsWithoutStyle(v: [
		string,
		string,
		string
	]): void;
	mergeCellsWithoutStyle(v: [
		number,
		number,
		number,
		number
	]): void;
	mergeCellsWithoutStyle(v: [
		number,
		number,
		number,
		number,
		string
	]): void;
	/**
	 * unmerging the cells breaks the style links
	 */
	unMergeCells(): void;
	unMergeCells(v: Range): void;
	unMergeCells(v: string): void;
	unMergeCells(v: Location): void;
	unMergeCells(top: number, left: number, bottom: number, right: number, sheetName?: string): void;
	unMergeCells(tl: string, br: string, sheetName?: string): void;
	unMergeCells(v: [
		string,
		string
	]): void;
	unMergeCells(v: [
		string,
		string,
		string
	]): void;
	unMergeCells(v: [
		number,
		number,
		number,
		number
	]): void;
	unMergeCells(v: [
		number,
		number,
		number,
		number,
		string
	]): void;
	fillFormula(range: Range | string | Location, formula: string, results?: ((r: number, c: number) => string | number) | number[] | number[][]): void;
	/**
	 * Using the image id from `Workbook.addImage`, set the background to the worksheet
	 */
	addBackgroundImage(imageId: number): void;
	getBackgroundImageId(): string;
	/**
	 * Using the image id from `Workbook.addImage`,
	 * embed an image within the worksheet to cover a range
	 */
	addImage(imageId: number, range: string | {
		editAs?: string;
	} & ImageRange & {
		hyperlinks?: ImageHyperlinkValue;
	} | {
		editAs?: string;
	} & ImagePosition & {
		hyperlinks?: ImageHyperlinkValue;
	}): void;
	getImages(): Array<{
		type: "image";
		imageId: string;
		range: ImageRange;
	}>;
	commit(): void;
	model: WorksheetModel;
	/**
	 * Worksheet protection
	 */
	protect(password: string, options: Partial<WorksheetProtection>): Promise<void>;
	unprotect(): void;
	/**
	 * Add a new table and return a reference to it
	 */
	addTable(tableProperties: TableProperties): Table;
	/**
	 * fetch table by name or id
	 */
	getTable(name: string): Table;
	/**
	 * delete table by name or id
	 */
	removeTable(name: string): void;
	/**
	 *  fetch table
	 */
	getTables(): [
		Table,
		void
	][];
	/**
	 * add conditionalFormattingOptions
	 */
	addConditionalFormatting(cf: ConditionalFormattingOptions): void;
	/**
	 * delete conditionalFormattingOptions
	 */
	removeConditionalFormatting(filter: any): void;
}
interface CalculationProperties {
	/**
	 * Whether the application shall perform a full recalculation when the workbook is opened
	 */
	fullCalcOnLoad: boolean;
}
interface WorksheetProperties {
	/**
	 * Color of the tab
	 */
	tabColor: Partial<Color>;
	/**
	 * The worksheet column outline level (default: 0)
	 */
	outlineLevelCol: number;
	/**
	 * The worksheet row outline level (default: 0)
	 */
	outlineLevelRow: number;
	/**
	 * The outline properties which controls how it will summarize rows and columns
	 */
	outlineProperties: {
		summaryBelow: boolean;
		summaryRight: boolean;
	};
	/**
	 * Default row height (default: 15)
	 */
	defaultRowHeight: number;
	/**
	 * Default column width (optional)
	 */
	defaultColWidth?: number;
	/**
	 * default: 55
	 */
	dyDescent: number;
	showGridLines: boolean;
}
interface AddWorksheetOptions {
	properties: Partial<WorksheetProperties>;
	pageSetup: Partial<PageSetup>;
	headerFooter: Partial<HeaderFooter>;
	views: Array<Partial<WorksheetView>>;
	state: WorksheetState;
}
interface WorkbookProperties {
	/**
	 * Set workbook dates to 1904 date system
	 */
	date1904: boolean;
}
interface JSZipGeneratorOptions {
	/**
	 * @default DEFLATE
	 */
	compression: "STORE" | "DEFLATE";
	compressionOptions: null | {
		/**
		 * @default 6
		 */
		level: number;
	};
}
interface XlsxReadOptions {
	/**
	 * The list of XML node names to ignore while parsing an XLSX file
	 */
	ignoreNodes: string[];
}
interface XlsxWriteOptions extends stream.xlsx.WorkbookWriterOptions {
	/**
	 * The option passed to JsZip#generateAsync(options)
	 */
	zip: Partial<JSZipGeneratorOptions>;
}
interface Xlsx {
	/**
	 * read from a file
	 */
	readFile(path: string, options?: Partial<XlsxReadOptions>): Promise<Workbook>;
	/**
	 * read from a stream
	 * @param stream
	 */
	read(stream: import("stream").Stream, options?: Partial<XlsxReadOptions>): Promise<Workbook>;
	/**
	 * load from an array buffer
	 * @param buffer
	 */
	load(buffer: Buffer$1, options?: Partial<XlsxReadOptions>): Promise<Workbook>;
	/**
	 * write to a buffer
	 */
	writeBuffer(options?: Partial<XlsxWriteOptions>): Promise<Buffer$1>;
	/**
	 * write to a file
	 */
	writeFile(path: string, options?: Partial<XlsxWriteOptions>): Promise<void>;
	/**
	 * write to a stream
	 */
	write(stream: import("stream").Stream, options?: Partial<XlsxWriteOptions>): Promise<void>;
}
type HeaderArray = (string | undefined | null)[];
type HeaderTransformFunction = (headers: HeaderArray) => HeaderArray;
interface FastCsvParserOptionsArgs {
	objectMode: boolean;
	delimiter: string;
	quote: string | null;
	escape: string;
	headers: boolean | HeaderTransformFunction | HeaderArray;
	renameHeaders: boolean;
	ignoreEmpty: boolean;
	comment: string;
	strictColumnHandling: boolean;
	discardUnmappedColumns: boolean;
	trim: boolean;
	ltrim: boolean;
	rtrim: boolean;
	encoding: string;
	maxRows: number;
	skipLines: number;
	skipRows: number;
}
interface QuoteColumnMap {
	[s: string]: boolean;
}
declare type QuoteColumns = boolean | boolean[] | QuoteColumnMap;
interface RowMap {
	[key: string]: any;
}
declare type RowHashArray = [
	string,
	any
][];
declare type RowArray = string[];
declare type Rows = RowArray | RowMap | RowHashArray;
declare type RowTransformCallback = (error?: Error | null, row?: Rows) => void;
interface RowTransformFunction {
	(row: Rows, callback: RowTransformCallback): void;
	(row: Rows): Rows;
}
interface FastCsvFormatterOptionsArgs {
	objectMode: boolean;
	delimiter: string;
	rowDelimiter: string;
	quote: string | boolean;
	escape: string;
	quoteColumns: QuoteColumns;
	quoteHeaders: QuoteColumns;
	headers: null | boolean | string[];
	includeEndRowDelimiter: boolean;
	writeBOM: boolean;
	transform: RowTransformFunction;
	alwaysWriteHeaders: boolean;
}
interface CsvReadOptions {
	dateFormats: string[];
	map(value: any, index: number): any;
	sheetName: string;
	parserOptions: Partial<FastCsvParserOptionsArgs>;
}
interface CsvWriteOptions {
	dateFormat: string;
	dateUTC: boolean;
	sheetName: string;
	sheetId: number;
	encoding: string;
	map(value: any, index: number): any;
	includeEmptyRows: boolean;
	formatterOptions: Partial<FastCsvFormatterOptionsArgs>;
}
interface Csv {
	/**
	 * read from a file
	 */
	readFile(path: string, options?: Partial<CsvReadOptions>): Promise<Worksheet>;
	/**
	 * read from a stream
	 */
	read(stream: import("stream").Stream, options?: Partial<CsvReadOptions>): Promise<Worksheet>;
	/**
	 * Create input stream for reading
	 */
	createInputStream(options?: Partial<CsvReadOptions>): import("events").EventEmitter;
	/**
	 * write to a buffer
	 */
	writeBuffer(options?: Partial<CsvWriteOptions>): Promise<Buffer$1>;
	/**
	 * write to a file
	 */
	writeFile(path: string, options?: Partial<CsvWriteOptions>): Promise<void>;
	/**
	 * write to a stream
	 */
	write(stream: import("stream").Stream, options?: Partial<CsvWriteOptions>): Promise<void>;
}
interface Media {
	type: string; // image,background
	name: string;
	extension: string;
	buffer: Buffer$1;
}
interface Address {
	sheetName?: string;
	address: string;
	col: string;
	row: string;
	$col$row: string;
}
interface Location {
	top: number;
	left: number;
	bottom: number;
	right: number;
}
interface CellMatrix {
	addCell(addressStr: string): void;
	getCell(addressStr: string): Cell;
	findCell(addressStr: string): Cell | undefined;
	findCellAt(sheetName: string, rowNumber: number, colNumber: number): Cell | undefined;
	addCellEx(address: string | Location): void;
	getCellEx(address: string | Location): Cell;
	findCellEx(address: string | Location, create: boolean): Cell | undefined;
	getCellAt(sheetName: string, rowNumber: number, colNumber: number): Cell;
	removeCellEx(address: string | Location): void;
	forEach(callback: (cell: Cell) => void): void;
	map<T>(callback: (cell: Cell) => T): T[];
	findSheet(address: string | Location, create: boolean): Cell[] | undefined;
	findSheetRow(sheet: Cell[][], address: string | Location, create: boolean): Row | undefined;
	findRowCell(row: any[], address: Address, create: boolean): Cell | undefined;
}
interface DefinedNamesRanges {
	name: string;
	ranges: string[];
}
type DefinedNamesModel = DefinedNamesRanges[];
interface DefinedNames {
	getMatrix(name: string): CellMatrix;
	// add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2
	add(locStr: string, name?: string): void;
	addEx(location: string | Location, name: string): Cell;
	remove(locStr: string | Location, name: string): void;
	removeEx(location: string | Location, name: string): void;
	removeAllNames(location: string | Location): void;
	forEach(callback: (name: string, cell: Cell) => void): void;
	// get all the names of a cell
	getNames(addressStr: string): string[];
	getNamesEx(address: string): string[];
	getRanges(name: string, matrix?: CellMatrix): DefinedNamesRanges;
	model: DefinedNamesModel;
}
interface WorkbookModel {
	creator: string;
	lastModifiedBy: string;
	lastPrinted: Date;
	created: Date;
	modified: Date;
	properties: WorkbookProperties;
	worksheets: Worksheet[];
	sheets: WorksheetModel[];
	definedNames: DefinedNamesModel;
	views: WorkbookView[];
	company: string;
	manager: string;
	title: string;
	subject: string;
	keywords: string;
	category: string;
	description: string;
	language: string;
	revision: Date;
	contentStatus: string;
	themes: string[];
	media: Media[];
}
declare class Workbook {
	category: string;
	company: string;
	creator: string;
	description: string;
	keywords: string;
	lastModifiedBy: string;
	created: Date;
	manager: string;
	modified: Date;
	lastPrinted: Date;
	properties: WorkbookProperties;
	subject: string;
	title: string;
	/**
	 * Workbook calculation Properties
	 */
	calcProperties: CalculationProperties;
	/**
	 * xlsx file format operations
	 */
	readonly xlsx: Xlsx;
	/**
	 * csv file format operations
	 */
	readonly csv: Csv;
	readonly nextId: number;
	readonly definedNames: DefinedNames;
	model: WorkbookModel;
	/**
	 * The Workbook views controls how many separate windows Excel will open when viewing the workbook.
	 */
	views: WorkbookView[];
	/**
	 * return a clone of worksheets in order
	 */
	worksheets: Worksheet[];
	/**
	 * Add a new worksheet and return a reference to it
	 */
	addWorksheet(name?: string, options?: Partial<AddWorksheetOptions>): Worksheet;
	removeWorksheetEx(worksheet: Worksheet): void;
	removeWorksheet(indexOrName: number | string): void;
	/**
	 * fetch sheet by name or id
	 */
	getWorksheet(indexOrName?: number | string): Worksheet | undefined;
	/**
	 * Iterate over all sheets.
	 *
	 * Note: `workbook.worksheets.forEach` will still work but this is better.
	 */
	eachSheet(callback: (worksheet: Worksheet, id: number) => void): void;
	clearThemes(): void;
	/**
	 * Add Image to Workbook and return the id
	 */
	addImage(img: Image): number;
	getImage(id: number): Image;
}
interface TableStyleProperties {
	/**
	 * The colour theme of the table
	 * @default 'TableStyleMedium2'
	 */
	theme?: "TableStyleDark1" | "TableStyleDark10" | "TableStyleDark11" | "TableStyleDark2" | "TableStyleDark3" | "TableStyleDark4" | "TableStyleDark5" | "TableStyleDark6" | "TableStyleDark7" | "TableStyleDark8" | "TableStyleDark9" | "TableStyleLight1" | "TableStyleLight10" | "TableStyleLight11" | "TableStyleLight12" | "TableStyleLight13" | "TableStyleLight14" | "TableStyleLight15" | "TableStyleLight16" | "TableStyleLight17" | "TableStyleLight18" | "TableStyleLight19" | "TableStyleLight2" | "TableStyleLight20" | "TableStyleLight21" | "TableStyleLight3" | "TableStyleLight4" | "TableStyleLight5" | "TableStyleLight6" | "TableStyleLight7" | "TableStyleLight8" | "TableStyleLight9" | "TableStyleMedium1" | "TableStyleMedium10" | "TableStyleMedium11" | "TableStyleMedium12" | "TableStyleMedium13" | "TableStyleMedium14" | "TableStyleMedium15" | "TableStyleMedium16" | "TableStyleMedium17" | "TableStyleMedium18" | "TableStyleMedium19" | "TableStyleMedium2" | "TableStyleMedium20" | "TableStyleMedium21" | "TableStyleMedium22" | "TableStyleMedium23" | "TableStyleMedium24" | "TableStyleMedium25" | "TableStyleMedium26" | "TableStyleMedium27" | "TableStyleMedium28" | "TableStyleMedium3" | "TableStyleMedium4" | "TableStyleMedium5" | "TableStyleMedium6" | "TableStyleMedium7" | "TableStyleMedium8" | "TableStyleMedium9";
	/**
	  * Highlight the first column (bold)
	  * @default false
	  */
	showFirstColumn?: boolean;
	/**
	  * Highlight the last column (bold)
	  * @default false
	  */
	showLastColumn?: boolean;
	/**
	  * Alternate rows shown with background colour
	  * @default false
	  */
	showRowStripes?: boolean;
	/**
	  * Alternate rows shown with background colour
	  * @default false
	  */
	showColumnStripes?: boolean;
}
interface TableColumnProperties {
	/**
	  * The name of the column, also used in the header
	  */
	name: string;
	/**
	  * Switches the filter control in the header
	  * @default false
	  */
	filterButton?: boolean;
	/**
	  * Label to describe the totals row (first column)
	  * @default 'Total'
	  */
	totalsRowLabel?: string;
	/**
	  * Name of the totals function
	  * @default 'none'
	  */
	totalsRowFunction?: "none" | "average" | "countNums" | "count" | "max" | "min" | "stdDev" | "var" | "sum" | "custom";
	/**
	  * Optional formula for custom functions
	  */
	totalsRowFormula?: string;
}
interface TableProperties {
	/**
	 * The name of the table
	 */
	name: string;
	/**
	 * The display name of the table
	 */
	displayName?: string;
	/**
	 * Top left cell of the table
	 */
	ref: string;
	/**
	 * Show headers at top of table
	 * @default true
	 */
	headerRow?: boolean;
	/**
	 * Show totals at bottom of table
	 * @default false
	 */
	totalsRow?: boolean;
	/**
	 * Extra style properties
	 * @default {}
	 */
	style?: TableStyleProperties;
	/**
	 * Column definitions
	 */
	columns: TableColumnProperties[];
	/**
	 * Rows of data
	 */
	rows: any[][];
}
type TableColumn = Required<TableColumnProperties>;
interface Table extends Required<TableProperties> {
	/**
	 * Commit changes
	 */
	commit: () => void;
	/**
	 * Remove a rows of data
	 */
	removeRows: (rowIndex: number, count: number) => void;
	/**
	 * Add a row of data, either insert at rowNumber or append
	 */
	addRow: (values: any[], rowNumber?: number) => void;
	/**
	 * Get column
	 */
	getColumn: (colIndex: number) => TableColumn;
	/**
	 * Add a new column, including column defn and values
	 * inserts at colNumber or adds to the right
	 */
	addColumn: (column: TableColumnProperties, values: any[], colIndex: number) => void;
	/**
	 * Remove a column with data
	 */
	removeColumns: (colIndex: number, count: number) => void;
}
declare namespace config {
	function setValue(key: "promise", promise: any): void;
}
declare namespace stream {
	namespace xlsx {
		interface WorkbookWriterOptions {
			/**
			 * Specifies a writable stream to write the XLSX workbook to.
			 */
			stream: import("stream").Stream;
			/**
			 * 	If stream not specified, this field specifies the path to a file to write the XLSX workbook to.
			 */
			filename: string;
			/**
			 * 	Specifies whether to use shared strings in the workbook. Default is false
			 */
			useSharedStrings: boolean;
			/**
			 * Specifies whether to add style information to the workbook.
			 * Styles can add some performance overhead. Default is false
			 */
			useStyles: boolean;
		}
		interface ArchiverZipOptions {
			comment: string;
			forceLocalTime: boolean;
			forceZip64: boolean;
			store: boolean;
			zlib: Partial<ZlibOptions>;
		}
		interface ZlibOptions {
			/**
			 * @default constants.Z_NO_FLUSH
			 */
			flush: number;
			/**
			 * @default constants.Z_FINISH
			 */
			finishFlush: number;
			/**
			 * @default 16*1024
			 */
			chunkSize: number;
			windowBits: number;
			level: number; // compression only
			memLevel: number; // compression only
			strategy: number; // compression only
			dictionary: Buffer$1 | NodeJS.TypedArray | DataView | ArrayBuffer; // deflate/inflate only, empty dictionary by default
		}
		interface WorkbookStreamWriterOptions extends WorkbookWriterOptions {
			/**
			 * Specifies whether to add style information to the workbook.
			 * Styles can add some performance overhead. Default is false
			 */
			zip: Partial<ArchiverZipOptions>;
		}
		class WorkbookWriter extends Workbook {
			constructor(options: Partial<WorkbookStreamWriterOptions>);
			// commit all worksheets, then add suplimentary files
			commit(): Promise<void>;
			addStyles(): Promise<void>;
			addThemes(): Promise<void>;
			addOfficeRels(): Promise<void>;
			addContentTypes(): Promise<void>;
			addApp(): Promise<void>;
			addCore(): Promise<void>;
			addSharedStrings(): Promise<void>;
			addWorkbookRels(): Promise<void>;
			addWorkbook(): Promise<void>;
		}
		interface WorkbookStreamReaderOptions {
			/**
			 * @default 'emit'
			 */
			worksheets?: "emit" | "ignore";
			/**
			 * @default 'cache'
			 */
			sharedStrings?: "cache" | "emit" | "ignore";
			/**
			 * @default 'ignore'
			 */
			hyperlinks?: "cache" | "emit" | "ignore";
			/**
			 * @default 'ignore'
			 */
			styles?: "cache" | "ignore";
			/**
			 * @default 'ignore'
			 */
			entries?: "emit" | "ignore";
		}
		class WorkbookReader extends Workbook {
			constructor(input: string | import("stream").Stream, options: Partial<WorkbookStreamReaderOptions>);
			read(): Promise<void>;
			[Symbol.asyncIterator](): AsyncGenerator<WorksheetReader>;
			parse(): AsyncIterator<any>;
		}
		interface WorksheetReaderOptions {
			workbook: Workbook;
			id: number;
			entry: import("stream").Stream;
			options: WorkbookStreamReaderOptions;
		}
		class WorksheetReader {
			constructor(options: WorksheetReaderOptions);
			read(): Promise<void>;
			[Symbol.asyncIterator](): AsyncGenerator<Row>;
			parse(): AsyncIterator<Array<any>>;
			dimensions(): number;
			columns(): number;
			getColumn(c: number): Column;
		}
	}
}
type Cells = Record<string, string>;
type TableKey = string | number;
type Table$1 = Record<TableKey, Record<string, string>>;
type MultiTable = Record<TableKey, Record<string, string>[]>;
type CellTable = Record<TableKey, Record<string, exceljs.Cell>>;
type MultiCellTable = Record<TableKey, Record<string, exceljs.Cell>[]>;
declare class Sheet {
	sheet: exceljs.Worksheet;
	name: string;
	id: number;
	constructor(sheet: exceljs.Worksheet);
	private _cells?;
	/**
	 *  `sheet.cells['A1']` 
	 */
	get cells(): Cells;
	private createCells;
	private guessTableOffset;
	/**
	 * key-value
	 * 
	 * @param offset  `"B2"`
	 * @param skip 
	 */
	makeCellTable(offset?: string, skip?: number): CellTable;
	/**
	 * key-value
	 * 
	 * @param offset  `"B2"`
	 * @param skip 
	 */
	makeTable(offset?: string, skip?: number): Table$1;
	/**
	 * key-value[]
	 *  `makeTable` 
	 * 
	 * @param offset  `"B2"`
	 * @param skip 
	 */
	makeMultiCellTable(offset?: string, skip?: number): MultiCellTable;
	/**
	 * key-value[]
	 *  `makeTable` 
	 * 
	 * @param offset  `"B2"`
	 * @param skip 
	 */
	makeMultiTable(offset?: string, skip?: number): MultiTable;
}
declare class Excel {
	private workbook;
	private uri?;
	/**
	 *
	 * @param fileUri 
	 */
	loadFile(fileUri: vscode.Uri): Promise<boolean>;
	private proxySheet;
	/**
	 * sheet
	 * @param indexOrName sheet
	 */
	getSheet(indexOrName?: number | string): y3.excel.Sheet | undefined;
	getAllSheets(): Sheet[];
}
declare namespace Table$2 {
	const path: {
		readonly toCN: {
			readonly editorunit: "\u5355\u4F4D";
			readonly soundall: "\u58F0\u97F3";
			readonly abilityall: "\u6280\u80FD";
			readonly editordecoration: "\u88C5\u9970\u7269";
			readonly editordestructible: "\u53EF\u7834\u574F\u7269";
			readonly editoritem: "\u7269\u54C1";
			readonly modifierall: "\u9B54\u6CD5\u6548\u679C";
			readonly projectileall: "\u6295\u5C04\u7269";
			readonly technologyall: "\u79D1\u6280";
		};
		readonly fromCN: {
			readonly : "editorunit";
			readonly : "soundall";
			readonly : "abilityall";
			readonly : "editordecoration";
			readonly : "editordestructible";
			readonly : "editoritem";
			readonly : "modifierall";
			readonly : "projectileall";
			readonly : "technologyall";
		};
		readonly toName: {
			readonly editorunit: "unit";
			readonly soundall: "sound";
			readonly abilityall: "ability";
			readonly editordecoration: "decoration";
			readonly editordestructible: "destructible";
			readonly editoritem: "item";
			readonly modifierall: "modifier";
			readonly projectileall: "projectile";
			readonly technologyall: "technology";
		};
		readonly fromName: {
			readonly unit: "editorunit";
			readonly sound: "soundall";
			readonly ability: "abilityall";
			readonly decoration: "editordecoration";
			readonly destructible: "editordestructible";
			readonly item: "editoritem";
			readonly modifier: "modifierall";
			readonly projectile: "projectileall";
			readonly technology: "technologyall";
		};
	};
	const name: {
		readonly toCN: {
			readonly unit: "\u5355\u4F4D";
			readonly decoration: "\u88C5\u9970\u7269";
			readonly item: "\u7269\u54C1";
			readonly ability: "\u6280\u80FD";
			readonly modifier: "\u9B54\u6CD5\u6548\u679C";
			readonly projectile: "\u6295\u5C04\u7269";
			readonly technology: "\u79D1\u6280";
			readonly destructible: "\u53EF\u7834\u574F\u7269";
			readonly sound: "\u58F0\u97F3";
		};
		readonly fromCN: {
			readonly : "unit";
			readonly : "decoration";
			readonly : "item";
			readonly : "ability";
			readonly : "modifier";
			readonly : "projectile";
			readonly : "technology";
			readonly : "destructible";
			readonly : "sound";
		};
	};
	const type: {
		readonly toLuaType: {
			readonly 100000: "number";
			readonly 100001: "boolean";
			readonly 100002: "integer";
			readonly 100003: "string";
			readonly 100004: "Point";
			readonly 100006: "Unit";
			readonly 100010: "UnitKey";
			readonly 100011: "table";
			readonly 100014: "Ability";
			readonly 100025: "Player";
			readonly 100026: "UnitGroup";
			readonly 100027: "PlayerGroup";
			readonly 100031: "Item";
			readonly 100032: "ItemKey";
			readonly 100039: "AbilityKey";
			readonly 100263: "Mover";
		};
		readonly toName: {
			readonly 100000: "\u5B9E\u6570";
			readonly 100001: "\u5E03\u5C14";
			readonly 100002: "\u6574\u6570";
			readonly 100003: "\u5B57\u7B26\u4E32";
			readonly 100004: "\u70B9";
			readonly 100006: "\u5355\u4F4D";
			readonly 100010: "\u5355\u4F4D\u7C7B\u578B";
			readonly 100011: "\u8868";
			readonly 100014: "\u6280\u80FD";
			readonly 100025: "\u73A9\u5BB6";
			readonly 100026: "\u5355\u4F4D\u7EC4";
			readonly 100027: "\u73A9\u5BB6\u7EC4";
			readonly 100031: "\u7269\u54C1";
			readonly 100032: "\u7269\u54C1\u7C7B\u578B";
			readonly 100039: "\u6280\u80FD\u7C7B\u578B";
			readonly 100263: "\u8FD0\u52A8\u5668";
		};
		readonly etype: {
			readonly 0: "\u5B57\u7B26\u4E32";
			readonly 1: "\u6574\u6570";
			readonly 2: "\u5B9E\u6570";
			readonly 4: "\u5E03\u5C14";
		};
		readonly type: {
			readonly 0: "\u5B57\u7B26\u4E32";
			readonly 1: "\u5B9E\u6570";
			readonly 2: "\u6574\u6570";
			readonly 3: "\u5E03\u5C14";
		};
	};
	type Path = keyof typeof path.toCN;
	type NameEN = keyof typeof name.toCN;
	type NameCN = keyof typeof name.fromCN;
	type TypeID = keyof typeof type.toLuaType;
}
type Row$1 = Record<string, string>;
type ReaderFunc<T> = (...rows: Row$1[]) => NoInfer<T> | undefined;
type AsFunc<T> = (content: string, source?: T, ...extraContents: string[]) => NoInfer<T> | undefined;
declare class AsRule<T> {
	private as?;
	constructor(as?: As<T> | undefined);
	protected value: any;
	applyAs(content: any, source?: T, ...extraContents: any[]): T | undefined;
	private _default?;
	/**
	 *  `undefined`
	 * @param value 
	 * @returns
	 */
	default(value?: T): this;
	private _finally?;
	/**
	 * 
	 * @param callback 
	 * @returns
	 */
	finally(callback: (value?: T) => T): this;
}
declare class ReaderRule<T> extends AsRule<T> {
	private reader;
	constructor(reader: ReaderFunc<T>, as?: As<T>);
	applyReader(rows: Row$1 | Row$1[], source?: T): T | undefined;
}
type Reader<T> = string | undefined | ReaderFunc<T> | ReaderRule<T>;
type As<T> = AsFunc<T> | AsRule<T>;
type EditorDataField<N extends y3.consts.Table.NameCN> = keyof y3.table.EditorData<N>;
type EditorDataFieldType<N extends y3.consts.Table.NameCN, F extends EditorDataField<N>> = y3.table.EditorData<N>[F];
type RuleData<N extends y3.consts.Table.NameCN> = {
	[key in EditorDataField<N>]: Reader<EditorDataFieldType<N, key>>;
};
type RuleField<N extends y3.consts.Table.NameCN> = {
	[key in EditorDataField<N>]: key;
};
declare class Rule<N extends y3.consts.Table.NameCN> {
	tableName: N;
	path: vscode.Uri;
	sheetName?: (number | string) | undefined;
	rule: this;
	/**
	 * excel
	 */
	reader: {
		/**
		 * excel
		 *  `undefined` 
		 * @param callback 
		 * @returns
		 */
		readonly rule: <T>(callback: ReaderFunc<T>) => ReaderRule<T>;
		/**
		 * 
		 * @param title 
		 * @param defaultValue 
		 * @returns
		 */
		readonly number: (title: string, defaultValue?: number) => ReaderRule<number>;
		/**
		 * 
		 */
		readonly integer: (title: string, defaultValue?: number) => ReaderRule<number>;
		/**
		 * 
		 * @param title 
		 * @param defaultValue 
		 * @returns
		 */
		readonly boolean: (title: string, defaultValue?: boolean) => ReaderRule<boolean>;
		/**
		 *  `default`
		 * @param title 
		 * @param separator 
		 * @param converter 
		 * @returns
		 */
		readonly string: (title: string, defaultValue?: string) => ReaderRule<string>;
		/**
		 *  `default`
		 * @param title 
		 * @param separator 
		 * @param converter 
		 * @returns
		 */
		readonly split: <T = string>(title: string, separator: string | RegExp, converter?: (value: string) => T) => ReaderRule<T[]>;
	};
	/**
	 * 
	 */
	as: {
		/**
		 * 
		 * @param value 
		 * @param defaultValue 
		 * @returns
		 */
		readonly number: (defaultValue?: number) => AsRule<number>;
		/**
		 * 
		 */
		readonly integer: (defaultValue?: number) => AsRule<number>;
		/**
		 * 
		 * @param value 
		 * @param defaultValue 
		 * @returns
		 */
		readonly string: (defaultValue?: string) => AsRule<string>;
		/**
		 * 
		 * @param value 
		 * @param defaultValue 
		 * @returns
		 */
		readonly boolean: (defaultValue?: boolean) => AsRule<boolean>;
		/**
		 *  `default`
		 * @param title 
		 * @param separator 
		 * @param converter 
		 * @returns
		 */
		readonly split: <T = string>(separator: string | RegExp, converter?: (value: string) => T) => AsRule<T[]>;
	};
	private _actions;
	/**
	 * 
	 */
	data: RuleData<N>;
	field: RuleField<N>;
	constructor(tableName: N, path: vscode.Uri, sheetName?: (number | string) | undefined);
	/**
	 *  `A1``B2` 
	 */
	offset?: string;
	/**
	 *  `1`
	 */
	skip?: number;
	/**
	 * key
	 * 
	 */
	key?: string;
	/**
	 * `key`
	 */
	template?: string;
	/**
	 * 
	 */
	overwrite?: boolean;
	/**
	 * 
	 */
	multi?: boolean;
	/**
	 * excel
	 * @param title excel
	 * @param field 
	 * @param as 
	 */
	def<F extends EditorDataField<N>>(title: string, field: F, as?: As<EditorDataFieldType<N, F>>): void;
	/**
	 * 
	 */
	apply(): Promise<void>;
	private getValue;
}
declare function loadFile(path: vscode.Uri | string, sheetName?: number | string): Promise<Sheet>;
declare function loadFileWithAllSheets(path: vscode.Uri | string): Promise<Sheet[]>;
declare function setBaseDir(path: vscode.Uri | string): void;
declare function rule<N extends Table$2.NameCN>(tableName: N, path: vscode.Uri | string, sheetName?: number | string): Rule<N>;
declare function init(): void;
interface UnitData {
	/**
	 * (%)
	 *
	 * 
	 */
	dodge_rate: number;
	/**
	 * 
	 */
	common_atk_type: any;
	/**
	 * 
	 *
	 * 
	 */
	body_size: number;
	/**
	 * 
	 *
	 * 
	 */
	pene_mag: number;
	/**
	 * 
	 *
	 * 
	 */
	intelligence_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	mini_map_icon_scale: number;
	/**
	 * x
	 */
	billboard_scale_x: number;
	/**
	 * 
	 *
	 * 
	 */
	pene_mag_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	default_behaviour_type: any;
	/**
	 * 
	 *
	 * 
	 */
	icon: any;
	/**
	 * 
	 */
	poolable: boolean;
	/**
	 * 
	 *
	 * 
	 */
	init_stock: number;
	/**
	 * 
	 *
	 * 
	 */
	passive_ability_list: any[];
	/**
	 * 
	 *
	 * 
	 */
	rotate_speed: number;
	/**
	 * 
	 *
	 * 
	 */
	agility_grow: number;
	/**
	 * 
	 */
	shop_range: number;
	/**
	 * 
	 *
	 * 
	 */
	move_type: any;
	/**
	 * 
	 *
	 * 
	 */
	defense_phy_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	attack_mag_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	mp_rec_grow: number;
	/**
	 * 
	 */
	fresnel_exp: number;
	/**
	 * 
	 *
	 * 
	 */
	speed_ratio_in_turn: number;
	/**
	 * 
	 *
	 * UI6
	 */
	hero_ability_list: any[];
	/**
	 * (%)
	 *
	 * 
	 */
	critical_dmg_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	bar_show_name: any;
	/**
	 * 
	 *
	 * 
	 */
	hp_rec_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	hp_max_grow: number;
	/**
	 * 
	 *
	 * ,
1//
	 */
	ori_bits: any;
	/**
	 * 
	 */
	is_open_disk_shadow: boolean;
	/**
	 * 
	 *
	 * 
	 */
	research_techs: any[];
	/**
	 * 
	 */
	enable_strict_facing_mode: boolean;
	/**
	 * 
	 *
	 * 
	 */
	mp_max_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	main_attr: any;
	/**
	 * 
	 *
	 * 
	 */
	pene_phy_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	keep_dead_body_time: number;
	/**
	 * 
	 *
	 * 
	 */
	attack_mag: number;
	/**
	 * 
	 *
	 * 
	 */
	sell_list: any;
	/**
	 * 
	 *
	 * 
	 */
	hp_rec: number;
	/**
	 * 
	 *
	 * 
	 */
	mp_color: any;
	/**
	 * 
	 *
	 * 
	 */
	mp_rec: number;
	/**
	 * 
	 */
	rescue_seeker_distance: number;
	/**
	 * nil
	 */
	vision_sector_rng_grow: number;
	/**
	 * (%)
	 *
	 * 
	 */
	dmg_reduction: number;
	/**
	 * 
	 *
	 * 
	 */
	ori_speed: number;
	/**
	 * 
	 *
	 * (
	 */
	start_rft: number;
	/**
	 * 
	 *
	 * 
	 */
	show_y3_extra_info: boolean;
	/**
	 * 
	 *
	 * 
	 */
	ori_speed_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	special_idle_anim: string;
	/**
	 * (%)
	 *
	 * 
	 */
	pene_phy_ratio: number;
	/**
	 * 
	 *
	 * 
	 */
	armor_type: any;
	/**
	 * 
	 *
	 * 
	 */
	is_mini_map_show: boolean;
	/**
	 * 
	 */
	simple_common_atk: any;
	/**
	 * 
	 *
	 * 
	 */
	attack_phy: number;
	/**
	 * 
	 */
	attack_interval_grow: number;
	/**
	 * 
	 */
	need_preview_billboard: boolean;
	/**
	 * (%)
	 *
	 * 
	 */
	heal_effect_grow: number;
	/**
	 * (%)
	 *
	 * 
	 */
	extra_dmg: number;
	/**
	 * (AI)
	 *
	 * (AI)
	 */
	alarm_range: number;
	/**
	 * 
	 *
	 * 
	 */
	sell_res_list: any[];
	/**
	 * 
	 */
	is_open_Xray: boolean;
	/**
	 * 
	 *
	 * 
	 */
	agility: number;
	/**
	 * 
	 *
	 * 
	 */
	mini_map_icon: any;
	/**
	 * y
	 */
	billboard_scale_y: number;
	/**
	 * 
	 */
	cc_walk_speed: number;
	/**
	 * 
	 *
	 * 
	 */
	die_anim: string;
	/**
	 * 
	 *
	 * XX
	 */
	tags: any[];
	/**
	 * nil
	 */
	height_offset: number;
	/**
	 * (%)
	 *
	 * 
	 */
	healing_effect_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	view_type: any;
	/**
	 * 
	 */
	cc_jump_height: number;
	/**
	 * (%)
	 *
	 * 
	 */
	critical_dmg: number;
	/**
	 * 
	 *
	 * 
	 */
	idle_anim: string;
	/**
	 * 
	 */
	disk_shadow_size: number;
	/**
	 * 
	 *
	 * 
	 */
	attack_phy_grow: number;
	/**
	 * 
	 *
	 * Tips
	 */
	description: string;
	/**
	 * 
	 */
	collision_radius_2: number;
	/**
	 * 
	 *
	 * 
	 */
	blood_bar: any;
	/**
	 * 
	 */
	billboard_height_offset: number;
	/**
	 * 
	 */
	physics_composite: any;
	/**
	 * 
	 */
	is_open_outline_pass: boolean;
	/**
	 * 
	 *
	 * 
	 */
	destroy_after_die: boolean;
	/**
	 * 
	 */
	fresnel_color: any;
	/**
	 * 
	 */
	use_fresnel: boolean;
	/**
	 * 
	 *
	 * 
	 */
	mp_max: number;
	/**
	 * 
	 *
	 * 
	 */
	defense_mag_grow: number;
	/**
	 * (%)
	 *
	 * 
	 */
	pene_phy_ratio_grow: number;
	/**
	 * 
	 */
	is_apply_role_color: boolean;
	/**
	 * 
	 */
	path_finding_external_size: number;
	/**
	 * 
	 */
	collision_points: any;
	/**
	 * 
	 *
	 * 
	 */
	vision_sector_angle_night: number;
	/**
	 * 
	 */
	role_color_scale: number;
	/**
	 * 
	 */
	state_list: any[];
	/**
	 * 
	 *
	 * 
	 */
	use_simple_mini_map_icon: boolean;
	/**
	 * 
	 */
	use_virtual_light: boolean;
	/**
	 * 
	 */
	attack_range_grow: number;
	/**
	 * ID
	 *
	 * 
	 */
	key: number;
	/**
	 * 
	 *
	 * 
	 */
	hp_max: number;
	/**
	 * 
	 */
	state_init: any;
	/**
	 * 
	 */
	sound_event_list: any[];
	/**
	 * (%)
	 *
	 * 
	 */
	pene_mag_ratio_grow: number;
	/**
	 * nil
	 */
	is_x_offset: boolean;
	/**
	 * 
	 */
	shop_camp_args: any;
	/**
	 * 
	 */
	kv: any;
	/**
	 * 
	 */
	rescuer_type: any;
	/**
	 * (%)
	 *
	 * 
	 */
	vampire_mag: number;
	/**
	 * nil
	 */
	width_offset: number;
	/**
	 * 
	 */
	cc_run_speed: number;
	/**
	 * 
	 */
	anim_state_name: string;
	/**
	 * 
	 */
	build_ignore_dyn_collision: boolean;
	/**
	 * 
	 *
	 * 
	 */
	build_res_cost_list: any[];
	/**
	 * 
	 *
	 * 
	 */
	vision_sector_angle_day: number;
	/**
	 * (%)
	 *
	 * ()
	 */
	attack_speed_grow: number;
	/**
	 * (%)
	 *
	 * 
	 */
	hit_rate: number;
	/**
	 * 
	 *
	 * 
	 */
	vision_true: number;
	/**
	 * 
	 */
	separate_enemy_icon: boolean;
	/**
	 * (%)
	 *
	 * 
	 */
	vampire_phy_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	affect_techs: any[];
	/**
	 * 
	 *
	 * 
	 */
	vision_true_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	hp_rec_percent: number;
	/**
	 * 
	 */
	shop_sell_type: any;
	/**
	 * 
	 *
	 * 
	 */
	pene_phy: number;
	/**
	 * (%)
	 *
	 * 
	 */
	hit_rate_grow: number;
	/**
	 * 
	 */
	shop_edit: any;
	/**
	 * 
	 *
	 * 
	 */
	billboard_name_font: any;
	/**
	 * 
	 *
	 * 
	 */
	move_limitation: any;
	/**
	 * 
	 *
	 * 
	 */
	is_shop: boolean;
	/**
	 * 
	 */
	y3_extra_info_show_type: any;
	/**
	 * 
	 *
	 * 
	 */
	type: any;
	/**
	 * 
	 *
	 * 
	 */
	has_mp: boolean;
	/**
	 * 
	 *
	 * 
	 */
	buy_res_list: any[];
	/**
	 * 
	 */
	attack_range: number;
	/**
	 * 
	 *
	 * 
	 */
	refresh_interval: number;
	/**
	 * 
	 *
	 * 
	 */
	vision_night: number;
	/**
	 * 
	 *
	 * 
	 */
	bar_slot_size: number;
	/**
	 * 
	 */
	jump_to_display: any;
	/**
	 * 
	 *
	 * UI6
	 */
	common_ability_list: any[];
	/**
	 * 
	 *
	 * 
	 */
	common_atk: any;
	/**
	 * 
	 *
	 * 
	 */
	angle_tolerance: number;
	/**
	 * 
	 *
	 * 
	 */
	suffix: string;
	/**
	 * 
	 *
	 * 
	 */
	collision_box_turning_enable: boolean;
	/**
	 * 
	 *
	 * 
	 */
	move_channel: any;
	/**
	 * 
	 *
	 * 
	 */
	drop_items_tuple: any[];
	/**
	 * 
	 *
	 * 
	 */
	bar_show_scale: boolean;
	/**
	 * 
	 *
	 * 
	 */
	attack_type: any;
	/**
	 * 
	 */
	rescue_seeker_type: any;
	/**
	 * (AI)
	 *
	 * (AI)
	 */
	cancel_alarm_range: number;
	/**
	 * 
	 *
	 * 
	 */
	pkg_slot_size: number;
	/**
	 * 
	 *
	 * 
	 */
	defense_mag: number;
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 
	 */
	tower_hatred_duration: number;
	/**
	 * 
	 */
	enable_item_slots: boolean;
	/**
	 * (%)
	 *
	 * 
	 */
	extra_dmg_grow: number;
	/**
	 * (%)
	 *
	 * 
	 */
	critical_chance: number;
	/**
	 * 
	 *
	 * 
	 */
	reward_exp: number;
	/**
	 * 
	 */
	preview_billboard_health_value: number;
	/**
	 * 
	 */
	max_balance_angle: number;
	/**
	 * 
	 *
	 * 
	 */
	model_height: number;
	/**
	 * 
	 */
	rescue_finish_return: boolean;
	/**
	 * 
	 *
	 * 
	 */
	hp_rec_percent_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	standard_walk_rate: number;
	/**
	 * nil
	 */
	vision_sector_angle_night_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	precondition_list: any[];
	/**
	 * 
	 *
	 * 
	 */
	vision_rng_grow: number;
	/**
	 * 
	 */
	attack_interval: number;
	/**
	 * RGB
	 */
	outline_pass_color: any;
	/**
	 * nil
	 */
	vision_sector_angle_day_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	strength: number;
	/**
	 * nil
	 */
	vision_sector_night_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	vision_night_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	vision_rng: number;
	/**
	 * 
	 *
	 * 501
	 */
	dynamic_collision_r: number;
	/**
	 * (%)
	 *
	 * 
	 */
	critical_chance_grow: number;
	/**
	 * nil
	 */
	is_z_offset: boolean;
	/**
	 * 
	 */
	fresnel_emissive_color_strength: number;
	/**
	 * (%)
	 *
	 * cd
	 */
	cd_reduce_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	defense_phy: number;
	/**
	 * 
	 *
	 * 
	 */
	level: number;
	/**
	 * 
	 *
	 * 
	 */
	blood_show_type: any;
	/**
	 * 
	 */
	model_opacity: number;
	/**
	 * 
	 */
	base_tint_color: any;
	/**
	 * 
	 *
	 * 
	 */
	force_show_on_mini_map: boolean;
	/**
	 * 
	 */
	base_color_mod: any;
	/**
	 * (%)
	 *
	 * 
	 */
	heal_effect: number;
	/**
	 * 
	 */
	build_time: number;
	/**
	 * (%)
	 *
	 * 
	 */
	dmg_reduction_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	mp_key: string;
	/**
	 * (%)
	 *
	 * cd
	 */
	cd_reduce: number;
	/**
	 * 
	 *
	 * 
	 */
	keep_target: boolean;
	/**
	 * 
	 *
	 * 
	 */
	name: string;
	/**
	 * 
	 *
	 * 
	 */
	can_flee: boolean;
	/**
	 * 
	 */
	cc_move_acc_rate: number;
	/**
	 * 
	 */
	cc_move_acc: number;
	/**
	 * 
	 *
	 * 
	 */
	walk_anim: string;
	/**
	 * 
	 */
	outline_pass_width: number;
	/**
	 * 
	 */
	rescue_seeker_interval: number;
	/**
	 * 
	 */
	enemy_mini_map_icon: any;
	/**
	 * 
	 *
	 * 
	 */
	strength_grow: number;
	/**
	 * (%)
	 *
	 * 
	 */
	vampire_phy: number;
	/**
	 * (%)
	 *
	 * :1/*
	 */
	attack_speed: number;
	/**
	 * 
	 *
	 * 
	 */
	vision_sector_night: number;
	/**
	 * (%)
	 *
	 * 
	 */
	healing_effect: number;
	/**
	 * 
	 *
	 * 
	 */
	model: any;
	/**
	 * 
	 *
	 * 
	 */
	intelligence: number;
	/**
	 * (%)
	 *
	 * 
	 */
	vampire_mag_grow: number;
	/**
	 * 
	 *
	 * 
	 */
	max_stock: number;
	/**
	 * 
	 *
	 * 
	 */
	vision_sector_rng: number;
	/**
	 * 
	 */
	counterattack_range: number;
	/**
	 * (%)
	 *
	 * 
	 */
	dodge_rate_grow: number;
	/**
	 * 
	 */
	use_base_tint_color: boolean;
	/**
	 * 
	 */
	build_upgrade_list: any[];
	/**
	 * (%)
	 *
	 * 
	 */
	pene_mag_ratio: number;
}
interface SoundData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 
	 */
	volume: number;
	/**
	 * 
	 */
	description: string;
	/**
	 * 2D
	 */
	sound_id: any;
	/**
	 * 
	 */
	min_dist: number;
	/**
	 * 
	 */
	fade_out_time: number;
	/**
	 * 
	 */
	speed: number;
	/**
	 * 
	 */
	max_dist: number;
	/**
	 * 
	 */
	total_time: number;
	/**
	 * 
	 */
	tags: any[];
	/**
	 * 
	 */
	icon: any;
	/**
	 * 2D
	 */
	sound_id_list: any[];
	/**
	 * 
	 */
	suffix: string;
	/**
	 * 
	 */
	group: number;
	/**
	 * 
	 */
	kv: any;
	/**
	 * 
	 */
	name: string;
	/**
	 * 
	 */
	priority: number;
	/**
	 * 
	 */
	type: number;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 
	 */
	fade_in_time: number;
}
interface AbilityData {
	/**
	 * 
	 */
	ability_stage_config: any;
	/**
	 * 
	 */
	type_priority_item: number;
	/**
	 * 
	 */
	can_ps_interrupt: boolean;
	/**
	 * 
	 */
	filter_condition_camp: any;
	/**
	 * 
	 */
	camp_priority_enemy: number;
	/**
	 * 
	 */
	type_priority_destructible: number;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 
	 */
	is_meele: boolean;
	/**
	 * 
	 */
	sp_sfx_list: any[];
	/**
	 * 
	 */
	can_bs_interrupt: boolean;
	/**
	 * 
	 */
	collection_continuously: boolean;
	/**
	 * 
	 */
	is_immediate: any;
	/**
	 * 
	 */
	arrow_width: string[];
	/**
	 * 
	 */
	arrow_length: string[];
	/**
	 * 
	 */
	cost_hp_can_die: boolean;
	/**
	 * 
	 */
	ability_hp_cost: string[];
	/**
	 * 
	 */
	magicbook_list: any[];
	/**
	 * 
	 */
	hit_sfx_list: any[];
	/**
	 * 
	 */
	ability_prepare_time: number;
	/**
	 * 
	 */
	filter_condition_move_channel_type: any;
	/**
	 * 
	 */
	ps_sfx_list: any[];
	/**
	 * 
	 */
	building_attack_range_sfx: any;
	/**
	 * 
	 */
	collection_destructible_tags: any;
	/**
	 * 
	 */
	suffix: string;
	/**
	 * 
	 */
	sound_event_list: any[];
	/**
	 * 
	 */
	kv: any;
	/**
	 * 
	 */
	influenced_by_move: boolean;
	/**
	 * 
	 */
	can_cast_when_hp_insufficient: boolean;
	/**
	 * 
	 */
	auto_pick: boolean;
	/**
	 * 
	 */
	type_priority_hero: number;
	/**
	 * 
	 */
	ability_cast_point: number;
	/**
	 * 
	 */
	can_cost_hp: boolean;
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 
	 */
	can_prepare_interrupt: boolean;
	/**
	 * 
	 */
	player_props_cost: any[];
	/**
	 * 
	 *
	 * 
	 */
	precondition_list: any[];
	/**
	 * 
	 */
	collection_animation: string;
	/**
	 * 
	 */
	ability_cost: string[];
	/**
	 * 
	 */
	hit_sound_effect: any[];
	/**
	 * 
	 */
	end_sound_effect: any[];
	/**
	 * 
	 */
	ability_cast_type: any;
	/**
	 * 
	 */
	is_autocast: boolean;
	/**
	 * 
	 */
	ability_stack_cd: string[];
	/**
	 * 
	 */
	type_priority_building: number;
	/**
	 * 
	 */
	ability_break_cast_range: string[];
	/**
	 * 
	 */
	type_priority_creature: number;
	/**
	 * 
	 */
	release_immediately_out_of_range: boolean;
	/**
	 * 
	 */
	ability_damage: string[];
	/**
	 * 
	 */
	show_building_attack_range: boolean;
	/**
	 * 
	 */
	need_turn_to_target: boolean;
	/**
	 * 
	 */
	ps_sound_effect: any[];
	/**
	 * 
	 */
	sector_angle: string[];
	/**
	 * 
	 */
	sp_count_down: boolean;
	/**
	 * 
	 */
	cold_down_time: string[];
	/**
	 * 
	 */
	circle_radius: string[];
	/**
	 * 
	 */
	is_charge_ability: boolean;
	/**
	 * 
	 */
	build_list: any[];
	/**
	 * 
	 */
	end_sfx_list: any[];
	/**
	 * 
	 */
	bs_sfx_list: any[];
	/**
	 * 
	 */
	name: string;
	/**
	 * 
	 */
	collection_animation_loop: boolean;
	/**
	 * 
	 */
	build_rotate: number;
	/**
	 * 
	 */
	camp_priority_self: number;
	/**
	 * 
	 */
	ability_build_subtype: any;
	/**
	 * 
	 */
	target_attribute: any;
	/**
	 * 
	 */
	can_autocast_when_attack_target: boolean;
	/**
	 * 
	 */
	sector_radius: string[];
	/**
	 * 
	 */
	filter_item_tags: any;
	/**
	 * 
	 */
	description: string;
	/**
	 * 
	 */
	forbid_unit_tags: any;
	/**
	 * 
	 */
	filter_unit_tags: any;
	/**
	 * 
	 */
	sp_sound_effect: any[];
	/**
	 * 
	 */
	cst_sfx_list: any[];
	/**
	 * 
	 */
	ability_icon: any;
	/**
	 * 
	 */
	cst_sound_effect: any[];
	/**
	 * 
	 */
	influenced_by_cd_reduce: boolean;
	/**
	 * 
	 */
	filter_condition_type: any;
	/**
	 * 
	 */
	tags: any[];
	/**
	 * 
	 */
	ability_cast_range: string[];
	/**
	 * 
	 */
	can_cache: boolean;
	/**
	 * 
	 */
	camp_priority_neutral: number;
	/**
	 * 
	 */
	sight_type: any;
	/**
	 * 
	 */
	ability_timeline_resource: any;
	/**
	 * 
	 */
	required_level: any;
	/**
	 * 
	 */
	ability_damage_range: string[];
	/**
	 * 
	 */
	ability_max_stack_count: string[];
	/**
	 * 
	 */
	pick_count: number;
	/**
	 * 
	 */
	can_interrupt_others: boolean;
	/**
	 * 
	 */
	ability_channel_time: number;
	/**
	 * 
	 */
	ability_bw_point: number;
	/**
	 * 
	 */
	ability_max_level: number;
	/**
	 * 
	 */
	can_cast_interrupt: boolean;
	/**
	 * 
	 */
	camp_priority_friend: number;
	/**
	 * 
	 */
	art_resource_btn: any;
	/**
	 * 
	 */
	bs_sound_effect: any[];
}
interface DecorationData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 
	 */
	material_color_intensity: number;
	/**
	 * 
	 */
	collision_height: any;
	/**
	 * 
	 */
	use_virtual_light: boolean;
	/**
	 * 
	 */
	model: any;
	/**
	 * 55
	 */
	icon: any;
	/**
	 * 
	 */
	effect_button: any;
	/**
	 * 
	 */
	attach_models: any;
	/**
	 * 
	 */
	receive_decal: boolean;
	/**
	 * 
	 */
	use_fresnel: boolean;
	/**
	 * 
	 */
	collision_box: any;
	/**
	 * 
	 */
	base_color_mod: any;
	/**
	 * 
	 */
	material_alpha: number;
	/**
	 * 
	 */
	fresnel_exp: number;
	/**
	 * 
	 */
	fresnel_emissive_color_strength: number;
	/**
	 * 
	 */
	name: string;
	/**
	 * 
	 */
	fresnel_color: any;
	/**
	 * 
	 */
	cast_shadow: boolean;
	/**
	 * nil
	 */
	enable_camera_collision: boolean;
	/**
	 * 
	 */
	use_physics: boolean;
	/**
	 * 
	 */
	enable_occlusion_perspective: boolean;
	/**
	 * 
	 */
	collision_points: any;
	/**
	 * 
	 */
	base_tint_color: any;
	/**
	 * 
	 */
	material_color: any;
	/**
	 * 
	 */
	suffix: string;
	/**
	 * 
	 */
	model_opacity: number;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 
	 */
	scale: number;
	/**
	 * 
	 */
	kv: any;
	/**
	 * 
	 */
	effect_list: any;
	/**
	 * 
	 */
	use_base_tint_color: boolean;
	/**
	 * 
	 */
	material_change: any;
	/**
	 * 
	 */
	description: string;
}
interface DestructibleData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 *  - 
	 */
	show_on_mini_map: boolean;
	/**
	 * 
	 */
	source_desc: string;
	/**
	 * 
	 *
	 * 
	 */
	body_size: number;
	/**
	 * 
	 */
	is_attacked: boolean;
	/**
	 * 
	 */
	destroy_on_die: boolean;
	/**
	 * 
	 */
	source_player_prop: any;
	/**
	 * 
	 */
	use_virtual_light: boolean;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 
	 */
	hp_max: number;
	/**
	 * 
	 */
	icon: any;
	/**
	 * 
	 */
	source_nums_init: number;
	/**
	 * 
	 */
	effect_list: any;
	/**
	 * 
	 */
	sound_event_list: any[];
	/**
	 * 
	 */
	receive_decal: boolean;
	/**
	 * 
	 */
	fresnel_emissive_color_strength: number;
	/**
	 * 
	 */
	source_type: any;
	/**
	 * 
	 */
	passable: boolean;
	/**
	 * nil
	 */
	dead_height_box_data: string;
	/**
	 * 
	 */
	source_refresh_interval: number;
	/**
	 * 
	 */
	enable_occlusion_perspective: boolean;
	/**
	 * 
	 */
	use_fresnel: boolean;
	/**
	 * 
	 */
	base_color_mod: any;
	/**
	 * 
	 */
	kv: any;
	/**
	 * 
	 */
	die_effect_list: any;
	/**
	 * 
	 */
	description: string;
	/**
	 * 
	 */
	material_alpha: number;
	/**
	 * 
	 */
	fresnel_exp: number;
	/**
	 * 
	 */
	base_tint_color: any;
	/**
	 * 
	 */
	source_item: any;
	/**
	 *  - 
	 */
	mini_map_color: any;
	/**
	 * 
	 */
	is_collected: boolean;
	/**
	 * 
	 */
	material_color_intensity: number;
	/**
	 * 
	 */
	material_color: any;
	/**
	 * 
	 *
	 * XX
	 */
	tags: any[];
	/**
	 * 
	 */
	fresnel_color: any;
	/**
	 * 
	 */
	is_selected: boolean;
	/**
	 * 
	 */
	collision_points_dead: any;
	/**
	 * 
	 */
	is_ability_target: boolean;
	/**
	 * 
	 */
	source_refresh_count: number;
	/**
	 * 
	 */
	model: any;
	/**
	 * 
	 */
	collision_points_alive: any;
	/**
	 * 
	 */
	source_nums_max: number;
	/**
	 * 
	 */
	suffix: string;
	/**
	 * 
	 */
	model_opacity: number;
	/**
	 * 
	 */
	destroy_delay: number;
	/**
	 * 
	 */
	name: string;
	/**
	 * 
	 */
	die_on_source_run_out: boolean;
	/**
	 * nil
	 */
	alive_height_box_data: string;
	/**
	 * 
	 */
	use_base_tint_color: boolean;
	/**
	 * 
	 */
	material_change: any;
	/**
	 * 
	 */
	collision_box: any;
}
interface ItemData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 
	 */
	delete_on_discard: boolean;
	/**
	 * 
	 *
	 * 
	 */
	discard_enable: boolean;
	/**
	 * 
	 *
	 * 
	 */
	compose_list: any[];
	/**
	 * 
	 */
	use_virtual_light: boolean;
	/**
	 * ID
	 *
	 * ID
	 */
	key: number;
	/**
	 * 
	 *
	 * 
	 */
	start_rft: number;
	/**
	 * 
	 *
	 * 
	 */
	precondition_list: any[];
	/**
	 * 
	 *
	 * 
	 */
	icon: any;
	/**
	 * 
	 */
	disable_overlapping: boolean;
	/**
	 * 
	 *
	 * 
	 */
	init_stock: number;
	/**
	 * 
	 */
	effect_list: any;
	/**
	 * 
	 */
	sound_event_list: any[];
	/**
	 * 
	 *
	 * 
	 */
	stack_type: any;
	/**
	 * 
	 *
	 * 
	 */
	refresh_interval: number;
	/**
	 * 
	 *
	 * 
	 */
	attached_ability: any;
	/**
	 * 
	 */
	use_fresnel: boolean;
	/**
	 * 
	 *
	 * 
	 */
	drop_stay_time: number;
	/**
	 * 
	 */
	fresnel_emissive_color_strength: number;
	/**
	 * 
	 */
	attached_passive_abilities: any[];
	/**
	 * 
	 *
	 * 
	 */
	description: string;
	/**
	 * 
	 */
	fresnel_color: any;
	/**
	 * 
	 *
	 * 
	 */
	discard_when_dead: boolean;
	/**
	 * 
	 */
	material_alpha: number;
	/**
	 * 
	 */
	material_color_intensity: number;
	/**
	 * 
	 *
	 * 
	 */
	auto_use: boolean;
	/**
	 * 
	 */
	item_billboard_type: any;
	/**
	 * 
	 */
	fresnel_exp: number;
	/**
	 * 
	 *
	 * 
	 */
	model: any;
	/**
	 * 
	 *
	 * 
	 */
	level: number;
	/**
	 * 
	 */
	base_tint_color: any;
	/**
	 * CD
	 *
	 * CDCD
	 */
	cd_type: string;
	/**
	 * 
	 */
	base_color_mod: any;
	/**
	 * 
	 *
	 * 
	 */
	hp_max: number;
	/**
	 * 
	 *
	 * 
	 */
	use_consume: number;
	/**
	 * 
	 *
	 * 
	 */
	maximum_charging: number;
	/**
	 * 
	 */
	kv: any;
	/**
	 * 
	 *
	 * 
	 */
	sell_res_list: any[];
	/**
	 * 
	 *
	 * 
	 */
	buy_res_list: any[];
	/**
	 * 
	 *
	 * 
	 */
	sale_enable: boolean;
	/**
	 * 
	 *
	 * XX
	 */
	tags: any[];
	/**
	 * 
	 */
	cur_stack: number;
	/**
	 * 
	 */
	material_color: any;
	/**
	 * 
	 *
	 * 
	 */
	maximum_stacking: number;
	/**
	 * 
	 */
	model_opacity: number;
	/**
	 * 
	 *
	 * 
	 */
	max_stock: number;
	/**
	 * 
	 *
	 * 
	 */
	suffix: string;
	/**
	 * 
	 */
	name: string;
	/**
	 * 
	 */
	cur_charge: number;
	/**
	 * 
	 */
	use_base_tint_color: boolean;
	/**
	 * 
	 */
	material_change: any;
	/**
	 * 
	 *
	 * 
	 */
	body_size: number;
}
interface ModifierData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 
	 */
	is_influence_self: boolean;
	/**
	 * 
	 */
	material_color_intensity: number;
	/**
	 * 
	 */
	get_effect_list: any;
	/**
	 * 
	 */
	attach_model_list: any;
	/**
	 * 
	 */
	same_origin_cover: boolean;
	/**
	 * 
	 */
	ign_inf_unit_tag: any[];
	/**
	 * 
	 */
	shield_type: any;
	/**
	 * 
	 */
	target_allow: any;
	/**
	 * 
	 */
	modifier_icon: any;
	/**
	 * 
	 */
	lose_effect_list: any;
	/**
	 * 
	 */
	sound_event_list: any[];
	/**
	 * 
	 */
	modifier_effect: any;
	/**
	 * 
	 */
	shield_change_of_cover: any;
	/**
	 * 
	 */
	inf_unit_tag: any[];
	/**
	 * 
	 */
	description: string;
	/**
	 * 
	 */
	modifier_cover_type: any;
	/**
	 * 
	 */
	layer_change_of_cover: any;
	/**
	 * 
	 */
	tags: any[];
	/**
	 * 
	 */
	material_alpha: number;
	/**
	 * 
	 */
	material_color: any;
	/**
	 * 
	 */
	layer_max: number;
	/**
	 * 
	 */
	modifier_type: any;
	/**
	 * 
	 */
	cycle_time: number;
	/**
	 * 
	 */
	ign_inf_unit_type: any;
	/**
	 * 
	 */
	name: string;
	/**
	 * 
	 */
	disappear_when_dead: boolean;
	/**
	 * 
	 */
	suffix: string;
	/**
	 * 
	 */
	halo_effect: any;
	/**
	 * 
	 */
	influence_rng: number;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 
	 */
	kv: any;
	/**
	 * 
	 */
	time_change_of_cover: any;
	/**
	 * 
	 */
	show_on_ui: boolean;
	/**
	 * 
	 */
	material_change: any;
	/**
	 * 
	 */
	shield_value: number;
}
interface ProjectileData {
	/**
	 * ID
	 */
	uid: string;
	/**
	 * 
	 */
	description: string;
	/**
	 * 
	 */
	effect_foes: any;
	/**
	 * 
	 *
	 * 
	 */
	move_limitation: any;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 
	 */
	tags: any[];
	/**
	 * 
	 */
	sfx_loop: boolean;
	/**
	 * 
	 */
	icon: any;
	/**
	 * 
	 */
	poolable: boolean;
	/**
	 * 
	 */
	effect_destroy_way_is_immediately: boolean;
	/**
	 * 
	 */
	sound_event_list: any[];
	/**
	 * 
	 *
	 * 
	 */
	move_channel: any;
	/**
	 * 
	 */
	max_duration: number;
	/**
	 * 
	 */
	kv: any;
	/**
	 * 
	 */
	name: string;
	/**
	 * 
	 */
	effect_friend: any;
	/**
	 * 
	 */
	suffix: string;
	/**
	 * 
	 */
	async_effect: boolean;
}
interface TechData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 
	 */
	affect_tags: any[];
	/**
	 * 
	 */
	description: string;
	/**
	 * 
	 *
	 * 
	 */
	suffix: string;
	/**
	 * 
	 */
	kv: any;
	/**
	 * 
	 */
	affect_all: boolean;
	/**
	 * 
	 */
	name: string;
	/**
	 * ID
	 *
	 * 
	 */
	key: number;
	/**
	 * 
	 */
	cells: any;
	/**
	 * 
	 */
	tags: any[];
	/**
	 * 
	 */
	max_lv: number;
}

interface MapSound {
}
interface MapAbility {
}
interface MapDecoration {
}
interface MapDestructible {
}
interface MapItem {
}
interface MapModifier {
}
interface MapProjectile {
}
interface MapTech {
}
type KV = Record<string, string | number | boolean>;
interface CommonPatch {
	/**
	 * 
	 */
	kv: KV;
}
type Data<T> = T & CommonPatch;
type EditorData<N extends Table$2.NameCN> = N extends "\u5355\u4F4D" ? Data<UnitData> & MapUnit : N extends "\u58F0\u97F3" ? Data<SoundData> & MapSound : N extends "\u6280\u80FD" ? Data<AbilityData> & MapAbility : N extends "\u88C5\u9970\u7269" ? Data<DecorationData> & MapDecoration : N extends "\u53EF\u7834\u574F\u7269" ? Data<DestructibleData> & MapDestructible : N extends "\u7269\u54C1" ? Data<ItemData> & MapItem : N extends "\u9B54\u6CD5\u6548\u679C" ? Data<ModifierData> & MapModifier : N extends "\u6295\u5C04\u7269" ? Data<ProjectileData> & MapProjectile : N extends "\u79D1\u6280" ? Data<TechData> & MapTech : never;
type ItemShape = string | boolean | number | bigint | null | TupleShape | MapShape | ArrayShape;
type ArrayShape = ItemShape[];
type TupleShape = {
	__tuple__: true;
	items: ItemShape[];
};
type MapShape = {
	[key: string]: any;
};
declare class FieldInfo {
	tableName: Table$2.NameCN;
	field: string;
	desc?: string;
	tips?: string;
	type?: string;
	constructor(tableName: Table$2.NameCN, field: string);
}
declare function ready(): Promise<void>;
declare class EditorObject<N extends Table$2.NameCN = Table$2.NameCN> {
	private manager;
	tableName: N;
	key: number;
	private _json?;
	private _name?;
	private _text?;
	uri?: vscode.Uri;
	constructor(manager: EditorManager, tableName: N, key: number);
	toString(): string;
	/**
	 * json
	 */
	get json(): y3.json.Json | undefined;
	get text(): string | undefined;
	set text(text: string);
	/**
	 * 
	 */
	private _data?;
	get data(): EditorData<N>;
	private get;
	set(key: string, value: ItemShape, convertType?: boolean): boolean;
	private rawGet;
	private rawSet;
	/**
	 * 
	 */
	get name(): string;
	private updateFile;
	getFieldInfo(field: string): y3.table.FieldInfo;
	private _fieldList?;
	listFields(): string[];
	private serialize;
	private deserialize;
	flushName(): void;
}
interface CreateOptions<N extends Table$2.NameCN> {
	/**
	 * 
	 */
	name?: string;
	/**
	 * key
	 */
	key?: number;
	/**
	 * 
	 */
	copyFrom?: number | EditorObject<N>;
	/**
	 * key
	 */
	overwrite?: boolean;
}
declare class EditorTable<N extends Table$2.NameCN = Table$2.NameCN> extends vscode.Disposable {
	private manager;
	name: N;
	uri: vscode.Uri;
	nameEN: {
		readonly : "unit";
		readonly : "decoration";
		readonly : "item";
		readonly : "ability";
		readonly : "modifier";
		readonly : "projectile";
		readonly : "technology";
		readonly : "destructible";
		readonly : "sound";
	}[N];
	private _objectCache;
	private watcher?;
	constructor(manager: EditorManager, name: N);
	toString(): string;
	/**
	 * 
	 * @param key key
	 * @returns 
	 */
	get(key: number): Promise<EditorObject<N> | undefined>;
	fetch(key: number): EditorObject<N> | undefined;
	private _listCache?;
	/**
	 * key
	 * @returns key
	 */
	getList(): Promise<number[]>;
	fetchList(): number[] | undefined;
	/**
	 * 
	 * @param key key
	 */
	delete(key: number): Promise<void>;
	/**
	 * key
	 * @param key key
	 * @param overwirte key
	 * @returns
	 */
	canUseKey(key: number, overwirte?: boolean): Promise<boolean>;
	/**
	 * key
	 * @returns
	 */
	makeNewKey(copyKey?: number): Promise<number>;
	/**
	 * 
	 * @param options 
	 * @returns
	 */
	create(options?: CreateOptions<N>): Promise<EditorObject<N> | undefined>;
	/**
	 * 
	 * @param key key
	 * @returns 
	 */
	getUri(key: number): vscode.Uri;
	getFieldInfo(field: string): FieldInfo;
	listFields(): string[];
	private _listActions;
	private resortList;
	private notifyChange;
	private changeTable;
	private _onDidChange;
	private initWatcher;
	onDidChange(callback: () => void): vscode.Disposable;
}
declare function getObject(uri: vscode.Uri | string): Promise<EditorObject | undefined>;
declare class EditorManager {
	rootUri: vscode.Uri;
	constructor(rootUri: vscode.Uri);
	editorTables: Map<Table$2.NameCN, EditorTable<Table$2.NameCN>>;
	loadObject<N extends Table$2.NameCN>(tableName: N, key: number): Promise<y3.table.EditorObject<N> | null>;
	/**
	 * 
	 * @param tableName 
	 * @returns 
	 */
	openTable<N extends Table$2.NameCN>(tableName: N): EditorTable<N>;
	private _allObjects?;
	private _allObjectsMap?;
	private _cacheVersion;
	private flushCache;
	getAllObjects(): Promise<y3.table.EditorObject<"\u5355\u4F4D" | "\u58F0\u97F3" | "\u6280\u80FD" | "\u88C5\u9970\u7269" | "\u53EF\u7834\u574F\u7269" | "\u7269\u54C1" | "\u9B54\u6CD5\u6548\u679C" | "\u6295\u5C04\u7269" | "\u79D1\u6280">[]>;
	getObjectsByKey(key: number): Promise<EditorObject[]>;
	flushName(): void;
}
declare function openTable<N extends Table$2.NameCN>(tableName: N): EditorTable<N>;
declare function getAllObjects(): Promise<y3.table.EditorObject<"\u5355\u4F4D" | "\u58F0\u97F3" | "\u6280\u80FD" | "\u88C5\u9970\u7269" | "\u53EF\u7834\u574F\u7269" | "\u7269\u54C1" | "\u9B54\u6CD5\u6548\u679C" | "\u6295\u5C04\u7269" | "\u79D1\u6280">[]>;
declare function getObjectsByKey(key: number): Promise<EditorObject[]>;
declare let fixedFloat: boolean;
declare function init$1(): void;
declare function ready$1(): Promise<void>;
declare function get(key: string | number | bigint): string | undefined;
declare function set(key: string | number | bigint, value: string): void;
declare function keyOf(value: string | number, preferNumber?: boolean): string | bigint;
declare function onDidChange(listener: () => void): vscode.Disposable;
export declare function download(options: string | URL | https.RequestOptions): Promise<Buffer>;
export declare let log: vscode.LogOutputChannel;
declare class File {
	private _data;
	write(data: Uint8Array): this;
	get buffer(): Buffer;
	get string(): string;
}
declare function readFile(uri: vscode.Uri | string, relativePath?: string): Promise<File | undefined>;
declare function writeFile(uri: vscode.Uri | string, relativePath: string | undefined, data: string): Promise<boolean>;
declare function writeFile(uri: vscode.Uri | string, data: string): Promise<boolean>;
interface DeleteOptions {
	/**
	 * 
	 */
	recursive?: boolean;
	/**
	 * 
	 */
	useTrash?: boolean;
}
declare function removeFile(uri: vscode.Uri | string, options?: DeleteOptions): Promise<boolean>;
declare function removeFile(uri: vscode.Uri | string, relativePath?: string, options?: DeleteOptions): Promise<boolean>;
declare function dir(uri: vscode.Uri | string, relativePath?: string): Promise<[
	string,
	vscode.FileType
][]>;
declare function scan(uri: vscode.Uri | string, relativePath?: string, partail?: (result: [
	string,
	vscode.FileType
][]) => void): Promise<[
	string,
	vscode.FileType
][]>;
declare function stat(uri: vscode.Uri | string, relativePath?: string): Promise<vscode.FileStat | undefined>;
declare function isFile(uri: vscode.Uri | string, relativePath?: string): Promise<boolean>;
declare function isDirectory(uri: vscode.Uri | string, relativePath?: string): Promise<boolean>;
declare function isExists(uri: vscode.Uri | string, relativePath?: string): Promise<boolean>;
interface CopyOptions {
	overwrite?: boolean;
	recursive?: boolean;
	nameMap?: string;
	pattern?: RegExp;
}
declare function copy(source: vscode.Uri | string, target: vscode.Uri | string, options?: CopyOptions): Promise<boolean>;
declare function isRelativePath(path: string): boolean;
declare function isAbsolutePath(path: string): boolean;
type Item = string | boolean | number | bigint | null | JObject | JArray;
type JArray = Item[];
type JObject = {
	[key: string]: Item;
};
interface formatOptions {
	stringify?: (value: any) => string | undefined;
	patchEdit?: (edit: jsonc.Edit) => jsonc.Edit;
	patchJson?: boolean;
}
declare class Json {
	private options?;
	private _text;
	constructor(text: string, options?: formatOptions | undefined);
	get text(): string;
	private _data?;
	get data(): JObject | undefined;
	private _tree?;
	get tree(): jsonc.Node | undefined;
	get(key: string): Item | undefined;
	private _patch?;
	set(key: string, value: any): boolean;
	private applyPatch;
}
declare function parse(text: string): any;
declare const encodeOptions: {
	readonly newline: "\n";
	readonly indent: "    ";
	readonly depth: 0;
};
declare const keywords: Set<string>;
declare function getValidName(name: string, reserved?: Set<string>): string;
declare function encode(jsObject: any, options?: Partial<typeof encodeOptions>): string;
declare function launch(): Promise<boolean>;
interface Version {
	version: number;
	display: string;
}
declare function getClient(): Promise<Version | undefined>;
declare function getServer(): Promise<Version | undefined>;
declare function needUpdate(): Promise<boolean>;
interface UpdateResult {
	client?: Version;
	server?: Version;
}
declare function onDidChange$1(callback: (result: UpdateResult) => void): void;
declare function askUpdate(): Promise<boolean>;
declare function init$2(): void;
declare class VersionCache<T> {
	private maker;
	private cache;
	constructor(maker: () => T | Promise<T>, cache: T);
	private version;
	private hasNew;
	updateVersion(): void;
	get(): Promise<T>;
}
type EditorVersion = "1.0" | "2.0" | "unknown";
declare class Map$1 {
	name: string;
	uri: vscode.Uri;
	id: bigint;
	editorTable: EditorManager;
	description: string;
	scriptUri: vscode.Uri;
	constructor(name: string, uri: vscode.Uri);
	start(): Promise<void>;
}
declare class Project {
	uri: vscode.Uri;
	constructor(uri: vscode.Uri);
	entryMapId: bigint;
	maps: Map$1[];
	entryMap?: Map$1;
	start(): Promise<void>;
	findMapByUri(uri: vscode.Uri): Map$1 | undefined;
}
declare class Env {
	private envChangeEmitter;
	onDidChange: vscode.Event<void>;
	private searchEditorUriByReg;
	private isValidEditorPath;
	private searchEditorUri;
	private getEditorVersion;
	private searchProjectByFolder;
	private searchProject;
	private getEditorExeUri;
	editorVersion: EditorVersion;
	editorUri?: vscode.Uri;
	editorExeUri?: vscode.Uri;
	mapUri?: vscode.Uri;
	scriptUri?: vscode.Uri;
	globalScriptUri?: vscode.Uri;
	y3Uri?: vscode.Uri;
	pluginUri?: vscode.Uri;
	projectUri?: vscode.Uri;
	editorTableUri?: vscode.Uri;
	excelUri?: vscode.Uri;
	ruleUri?: vscode.Uri;
	project?: Project;
	currentMap?: Map$1;
	private _editorTablePath;
	get editorTablePath(): string;
	private _timer?;
	private fireOnDidReload;
	updateEditor(askUser?: boolean): Promise<void>;
	editorReady(askUser?: boolean): Promise<void>;
	updateCurrentMap(map: Map$1): void;
	updateMap(search: boolean, askUser: boolean): Promise<void>;
	mapReady(askUser?: boolean): Promise<void>;
}
export declare const env: Env;
interface ExportInfo {
	name: string;
	async: boolean;
	line: number;
}
declare class Plugin {
	uri: vscode.Uri;
	name: string;
	private rawCode?;
	private fixedCode?;
	private script?;
	private parseError?;
	private exports;
	constructor(uri: vscode.Uri, name: string);
	setCode(code: string): void;
	reload(): Promise<void>;
	private parse;
	getExports(): Promise<Record<string, ExportInfo>>;
	running: boolean;
	run(funcName: string, sandbox: vm.Context): Promise<void>;
	private _onceDidRun;
	private fireDidRun;
	onceDidRun(callback: (data: {
		funcName: string;
		result: any;
	}) => void | Promise<void>): void;
}
declare class PluginManager extends vscode.Disposable {
	dir: vscode.Uri;
	private _ready;
	private _disposables;
	private _onDidChange;
	constructor(dir: vscode.Uri);
	private notifyChange;
	onDidChange: vscode.Event<void>;
	plugins: Record<string, Plugin>;
	private loadPlugins;
	private ready;
	private static requireCache;
	private makeSandbox;
	getName(uri: vscode.Uri): string | undefined;
	findPlugin(uri: vscode.Uri): Promise<Plugin | undefined>;
	run(uri: vscode.Uri, funcName: string): Promise<void>;
	getAll(): Promise<Plugin[]>;
	runAll(funcName: string): Promise<number>;
}
declare function runAllPlugins(funcName: string): Promise<void>;
declare function onceDidRun(callback: (data: {
	funcName: string;
	result: any;
}) => void | Promise<void>): void;
declare function getManager(): PluginManager | undefined;
declare function init$3(): Promise<void>;
export declare let helper: vscode.ExtensionContext;
/**
 *  Uri
 * @returns
 */
export declare function uri(base: vscode.Uri | string, ...paths: string[]): vscode.Uri;
/**
 * Y3
 * @returns
 */
export declare function extensionPath(...paths: string[]): vscode.Uri;
export declare function setContext(ctx: vscode.ExtensionContext): void;
/**
 * 
 * @param args 
 */
export declare function print(...args: any[]): void;
/**
 * VSCode
 * @param uri 
 */
export declare function open(uri: vscode.Uri | string, line?: number): void;
/**
 * Windows
 * @param uri 
 */
export declare function openInExplorer(uri: vscode.Uri | string): void;
export declare function sleep(ms: number): Promise<void>;
export declare function assert(exp: any, msg?: string): asserts exp;

declare namespace exceljs {
	export { AboveAverageRuleType, AddWorksheetOptions, Address, Alignment, Anchor, AutoFilter, Border, BorderDiagonal, BorderStyle, Borders, Buffer$1 as Buffer, CalculationProperties, Cell, CellErrorValue, CellFormulaValue, CellHyperlinkValue, CellIsOperators, CellIsRuleType, CellMatrix, CellModel, CellRichTextValue, CellSharedFormulaValue, CellValue, CfvoTypes, Color, ColorScaleRuleType, Column, Comment, CommentEditAs, CommentMargins, CommentProtection, ConditionalFormattingBaseRule, ConditionalFormattingOptions, ConditionalFormattingRule, ContainsTextOperators, ContainsTextRuleType, Csv, CsvReadOptions, CsvWriteOptions, Cvfo, DataBarRuleType, DataValidation, DataValidationOperator, DefinedNames, DefinedNamesModel, DefinedNamesRanges, DocumentType, ErrorValue, ExpressionRuleType, FastCsvFormatterOptionsArgs, FastCsvParserOptionsArgs, Fill, FillGradientAngle, FillGradientPath, FillPattern, FillPatterns, Font, FormulaType, GradientStop, HeaderArray, HeaderFooter, HeaderTransformFunction, IAnchor, IconSetRuleType, IconSetTypes, Image, ImageHyperlinkValue, ImagePosition, ImageRange, JSZipGeneratorOptions, Location, Margins, Media, PageSetup, PaperSize, Protection, QuoteColumnMap, QuoteColumns, Range, ReadingOrder, RelationshipType, RichText, Row, RowArray, RowBreak, RowHashArray, RowMap, RowModel, RowTransformCallback, RowTransformFunction, RowValues, Rows, Style, Table, TableColumn, TableColumnProperties, TableProperties, TableStyleProperties, TimePeriodRuleType, TimePeriodTypes, Top10RuleType, ValueType, Workbook, WorkbookModel, WorkbookProperties, WorkbookView, Worksheet, WorksheetModel, WorksheetProperties, WorksheetProtection, WorksheetState, WorksheetView, WorksheetViewCommon, WorksheetViewFrozen, WorksheetViewNormal, WorksheetViewSplit, Xlsx, XlsxReadOptions, XlsxWriteOptions, config, stream };
}
declare namespace version {
	export { askUpdate, getClient, getServer, init$2 as init, needUpdate, onDidChange$1 as onDidChange };
}
declare namespace excel {
	export { CellTable, Excel, MultiCellTable, MultiTable, Sheet, Table$1 as Table, init, loadFile, loadFileWithAllSheets, rule, setBaseDir };
}
declare namespace table {
	export { EditorData, EditorManager, EditorObject, EditorTable, FieldInfo, fixedFloat, getAllObjects, getObject, getObjectsByKey, openTable, ready };
}
declare namespace language {
	export { get, init$1 as init, keyOf, onDidChange, ready$1 as ready, set };
}
declare namespace fs {
	export { copy, dir, isAbsolutePath, isDirectory, isExists, isFile, isRelativePath, readFile, removeFile, scan, stat, writeFile };
}
declare namespace json {
	export { Item, JArray, JObject, Json, formatOptions, parse };
}
declare namespace lua {
	export { encode, getValidName, keywords };
}
declare namespace tracy {
	export { launch };
}
declare namespace consts {
	export { Table$2 as Table };
}
declare namespace plugin {
	export { getManager, init$3 as init, onceDidRun, runAllPlugins };
}
declare namespace y3 {
	export { consts, excel, exceljs, fs, json, language, lua, plugin, table, tracy, version };
}

export {
	VersionCache as Cache,
	consts,
	excel,
	exceljs,
	fs,
	is,
	json,
	language,
	lua,
	plugin,
	table,
	tracy,
	version,
};

export {};
